<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/Naltox/telegram-node-bot"

    >telegram-node-bot (v4.0.5)</a>
</h1>
<h4>Module for creating Telegram bots.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.telegram-node-bot">module telegram-node-bot</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.BaseCommand">
            function <span class="apidocSignatureSpan">telegram-node-bot.</span>BaseCommand
            <span class="apidocSignatureSpan">(scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.BaseLogger">
            function <span class="apidocSignatureSpan">telegram-node-bot.</span>BaseLogger
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.BaseScopeExtension">
            function <span class="apidocSignatureSpan">telegram-node-bot.</span>BaseScopeExtension
            <span class="apidocSignatureSpan">(scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.BaseStorage">
            function <span class="apidocSignatureSpan">telegram-node-bot.</span>BaseStorage
            <span class="apidocSignatureSpan">(storage, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.BaseUpdateFetcher">
            function <span class="apidocSignatureSpan">telegram-node-bot.</span>BaseUpdateFetcher
            <span class="apidocSignatureSpan">(api, logger)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.InlineScope">
            function <span class="apidocSignatureSpan">telegram-node-bot.</span>InlineScope
            <span class="apidocSignatureSpan">(update, api, waitingChosenResults, waitingQueries)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.InputFile">
            function <span class="apidocSignatureSpan">telegram-node-bot.</span>InputFile
            <span class="apidocSignatureSpan">(fileId, filePath, fileUrl, fileName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.RegexpCommand">
            function <span class="apidocSignatureSpan">telegram-node-bot.</span>RegexpCommand
            <span class="apidocSignatureSpan">(regexp, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Scope">
            function <span class="apidocSignatureSpan">telegram-node-bot.</span>Scope
            <span class="apidocSignatureSpan">( update, api, extensions, waitingRequests, waitingCallbackQueries, logger, sessionStorage, waitForUpdate, waitForCallback )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Telegram">
            function <span class="apidocSignatureSpan">telegram-node-bot.</span>Telegram
            <span class="apidocSignatureSpan">(token, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.TelegramApi">
            function <span class="apidocSignatureSpan">telegram-node-bot.</span>TelegramApi
            <span class="apidocSignatureSpan">(token, logger)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.TelegramBaseCallbackQueryController">
            function <span class="apidocSignatureSpan">telegram-node-bot.</span>TelegramBaseCallbackQueryController
            <span class="apidocSignatureSpan">(query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.TelegramBaseController">
            function <span class="apidocSignatureSpan">telegram-node-bot.</span>TelegramBaseController
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.TelegramBaseInlineQueryController">
            function <span class="apidocSignatureSpan">telegram-node-bot.</span>TelegramBaseInlineQueryController
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.TextCommand">
            function <span class="apidocSignatureSpan">telegram-node-bot.</span>TextCommand
            <span class="apidocSignatureSpan">(textPattern, handler)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">telegram-node-bot.</span>Models</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.telegram-node-bot.Models">module telegram-node-bot.Models</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.Animation">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Animation
            <span class="apidocSignatureSpan">(fileId, thumb, fileName, mimeType, fileSize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.Audio">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Audio
            <span class="apidocSignatureSpan">(fileId, duration, performer, title, mimeType, fileSize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.CallbackQuery">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>CallbackQuery
            <span class="apidocSignatureSpan">( id, from, message, inlineMessageId, chatInstance, data, gameShortName )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.Chat">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Chat
            <span class="apidocSignatureSpan">( id, type, title, username, firstName, lastName, allMembersAreAdministrators )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.ChatMember">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>ChatMember
            <span class="apidocSignatureSpan">(user, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.ChosenInlineResult">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>ChosenInlineResult
            <span class="apidocSignatureSpan">(resultId, from, location, inlineMessageId, query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.Contact">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Contact
            <span class="apidocSignatureSpan">(phoneNumber, firstName, lastName, userId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.Document">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Document
            <span class="apidocSignatureSpan">(fileId, thumb, fileName, mimeType, fileSize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.File">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>File
            <span class="apidocSignatureSpan">(fileId, fileSize, filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.ForceReply">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>ForceReply
            <span class="apidocSignatureSpan">(forceReply, selective)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.Game">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Game
            <span class="apidocSignatureSpan">(title, description, photo, text, textEntities, animation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.GameHighScore">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>GameHighScore
            <span class="apidocSignatureSpan">(position, user, score)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineKeyboardButton">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineKeyboardButton
            <span class="apidocSignatureSpan">(text, url, callbackData, switchInlineQuery, switchInlineQueryCurrentChat, callbackGame)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineKeyboardMarkup">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineKeyboardMarkup
            <span class="apidocSignatureSpan">(inlineKeyboard)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQuery">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQuery
            <span class="apidocSignatureSpan">(id, from, location, query, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResult">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResult
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultArticle">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultArticle
            <span class="apidocSignatureSpan">( type, id, title, inputMessageContent, replyMarkup, url, hideUrl, description, thumbUrl, thumbWidth, thumbHeight )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultAudio">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultAudio
            <span class="apidocSignatureSpan">( type, id, audioUrl, title, caption, performer, audioDuration, replyMarkup, inputMessageContent )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedAudio">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultCachedAudio
            <span class="apidocSignatureSpan">(type, id, audioFileId, caption, replyMarkup, inputMessageContent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedDocument">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultCachedDocument
            <span class="apidocSignatureSpan">( type, id, title, documentFileId, description, caption, replyMarkup, inputMessageContent )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedGif">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultCachedGif
            <span class="apidocSignatureSpan">( type, id, gifFileId, title, caption, replyMarkup, inputMessageContent )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedMpeg4Gif">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultCachedMpeg4Gif
            <span class="apidocSignatureSpan">( type, id, mpeg4FileId, title, caption, replyMarkup, inputMessageContent )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedPhoto">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultCachedPhoto
            <span class="apidocSignatureSpan">( type, id, photoFileId, title, description, caption, replyMarkup, inputMessageContent )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedSticker">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultCachedSticker
            <span class="apidocSignatureSpan">(type, id, stickerFileId, replyMarkup, inputMessageContent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedVideo">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultCachedVideo
            <span class="apidocSignatureSpan">( type, id, videoFileId, title, description, caption, replyMarkup, inputMessageContent )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedVoice">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultCachedVoice
            <span class="apidocSignatureSpan">( type, id, voiceFileId, title, caption, replyMarkup, inputMessageContent )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultContact">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultContact
            <span class="apidocSignatureSpan">( type, id, phoneNumber, firstName, lastName, replyMarkup, inputMessageContent, thumbUrl, thumbWidth, thumbHeight )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultDocument">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultDocument
            <span class="apidocSignatureSpan">( type, id, title, caption, documentUrl, mimeType, description, replyMarkup, inputMessageContent, thumbUrl, thumbWidth, thumbHeight )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultGame">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultGame
            <span class="apidocSignatureSpan">(type, id, gameShortName, replyMarkup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultGif">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultGif
            <span class="apidocSignatureSpan">( type, id, gifUrl, gifWidth, gifHeight, thumbUrl, title, caption, replyMarkup, inputMessageContent )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultLocation">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultLocation
            <span class="apidocSignatureSpan">( type, id, latitude, longitude, title, replyMarkup, inputMessageContent, thumbUrl, thumbWidth, thumbHeight )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultMpeg4Gif">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultMpeg4Gif
            <span class="apidocSignatureSpan">( type, id, mpeg4Url, mpeg4Width, mpeg4Height, thumbUrl, title, caption, replyMarkup, inputMessageContent )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultPhoto">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultPhoto
            <span class="apidocSignatureSpan">( type, id, photoUrl, thumbUrl, photoWidth, photoHeight, title, description, caption, replyMarkup, inputMessageContent )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultVenue">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultVenue
            <span class="apidocSignatureSpan">( type, id, latitude, longitude, title, address, foursquareId, replyMarkup, inputMessageContent, thumbUrl, thumbWidth, thumbHeight )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultVideo">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultVideo
            <span class="apidocSignatureSpan">( type, id, videoUrl, mimeType, thumbUrl, title, caption, videoWidth, videoHeight, videoDuration, description, replyMarkup, inputMessageContent )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultVoice">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultVoice
            <span class="apidocSignatureSpan">( type, id, voiceUrl, title, caption, voiceDuration, replyMarkup, inputMessageContent )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InputContactMessageContent">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InputContactMessageContent
            <span class="apidocSignatureSpan">(phoneNumber, firstName, lastName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InputLocationMessageContent">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InputLocationMessageContent
            <span class="apidocSignatureSpan">(latitude, longitude)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InputMessageContent">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InputMessageContent
            <span class="apidocSignatureSpan">(raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InputTextMessageContent">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InputTextMessageContent
            <span class="apidocSignatureSpan">(messageText, parseMode, disableWebPagePreview)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.InputVenueMessageContent">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InputVenueMessageContent
            <span class="apidocSignatureSpan">(latitude, longitude, title, address, foursquareId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.KeyboardButton">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>KeyboardButton
            <span class="apidocSignatureSpan">(text, requestContact, requestLocation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.Location">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Location
            <span class="apidocSignatureSpan">(longitude, latitude)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.Message">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Message
            <span class="apidocSignatureSpan">( messageId, from, date, chat, forwardFrom, forwardFromChat, forwardFromMessageId, forwardDate, replyToMessage, editDate, text, entities, audio, document, game, photo, sticker, video, voice, caption, contact, location, venue, newChatMember, leftChatMember, newChatTitle, newChatPhoto, deleteChatPhoto, groupChatCreated, supergroupChatCreated, channelChatCreated, migrateToChatId, migrateFromChatId, pinnedMessage )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.MessageEntity">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>MessageEntity
            <span class="apidocSignatureSpan">(type, offset, length, url, user)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.PhotoSize">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>PhotoSize
            <span class="apidocSignatureSpan">(fileId, width, height, fileSize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.ReplyKeyboardMarkup">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>ReplyKeyboardMarkup
            <span class="apidocSignatureSpan">(keyboard, resizeKeyboard, oneTimeKeyboard, selective)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.ReplyKeyboardRemove">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>ReplyKeyboardRemove
            <span class="apidocSignatureSpan">(removeKeyboard, selective)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.ResponseParameters">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>ResponseParameters
            <span class="apidocSignatureSpan">(migrateToChatId, retryAfter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.Sticker">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Sticker
            <span class="apidocSignatureSpan">(fileId, width, height, thumb, emoji, fileSize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.Update">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Update
            <span class="apidocSignatureSpan">( updateId, message, editedMessage, channelPost, editedChannelPost, inlineQuery, chosenInlineResult, callbackQuery )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.User">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>User
            <span class="apidocSignatureSpan">(id, firstName, lastName, username)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.UserProfilePhotos">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>UserProfilePhotos
            <span class="apidocSignatureSpan">(totalCount, photos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.Venue">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Venue
            <span class="apidocSignatureSpan">(location, title, address, foursquareId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.Video">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Video
            <span class="apidocSignatureSpan">( fileId, width, height, duration, thumb, mimeType, fileSize )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.Voice">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Voice
            <span class="apidocSignatureSpan">(fileId, duration, mimeType, fileSize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.telegram-node-bot.Models.WebhookInfo">
            function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>WebhookInfo
            <span class="apidocSignatureSpan">( url, hasCustomCertificate, pendingUpdateCount, lastErrorDate, lastErrorMessage, maxConnections, allowedUpdates )</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.telegram-node-bot" id="apidoc.module.telegram-node-bot">module telegram-node-bot</a></h1>


    <h2>
        <a href="#apidoc.element.telegram-node-bot.BaseCommand" id="apidoc.element.telegram-node-bot.BaseCommand">
        function <span class="apidocSignatureSpan">telegram-node-bot.</span>BaseCommand
        <span class="apidocSignatureSpan">(scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class BaseCommand {
<span class="apidocCodeCommentSpan">    /**
     * Tests message
     *
     * @param {Scope} scope
     * @returns {boolean}
     */
</span>    test(scope) {
        throw &#x27;Not implemented&#x27;
    }

    /**
     * Returns handler method name in controller
     *
     * @returns {string}
     */
    get handlerName() { throw &#x27;Not implemented&#x27; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.BaseLogger" id="apidoc.element.telegram-node-bot.BaseLogger">
        function <span class="apidocSignatureSpan">telegram-node-bot.</span>BaseLogger
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class BaseLogger {
<span class="apidocCodeCommentSpan">    /**
     * Any log
     *
     * @param {Object} data
     */
</span>    log(data) { throw &#x27;Not implemented&#x27; }

    /**
     * Warning log
     *
     * @param {Object} data
     */
    warn(data) { throw &#x27;Not implemented&#x27; }

    /**
     * Error log
     *
     * @param {Object} data
     */
    error(data) { throw &#x27;Not implemented&#x27; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.BaseScopeExtension" id="apidoc.element.telegram-node-bot.BaseScopeExtension">
        function <span class="apidocSignatureSpan">telegram-node-bot.</span>BaseScopeExtension
        <span class="apidocSignatureSpan">(scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class BaseScopeExtension {
<span class="apidocCodeCommentSpan">    /**
     *
     * @param {Scope} scope
     */
</span>    constructor(scope) { }

    /**
     * This method will be called by your extension user ( $.yourExtension(args...) )
     * @param {...*}
     */
    process() { throw &#x27;Not implemented&#x27; }

    /**
     * You should return your extension name here. That name will be in scope. ( $.yourExtensionName )
     * @returns {string}
     */
    get name() { throw &#x27;Not implemented&#x27; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.BaseStorage" id="apidoc.element.telegram-node-bot.BaseStorage">
        function <span class="apidocSignatureSpan">telegram-node-bot.</span>BaseStorage
        <span class="apidocSignatureSpan">(storage, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class BaseStorage {
<span class="apidocCodeCommentSpan">    /**
     * @param {string} storage
     * @param {string} key
     * @returns {Promise&#x3c;Object&#x3e;}
     */
</span>    get(storage, key) { throw &#x27;Not implemented&#x27; }

    /**
     * @param {string} storage
     * @param {string} key
     * @param {Object} data
     * @returns {Promise&#x3c;&#x3e;}
     */
    set(storage, key, data) { throw &#x27;Not implemented&#x27; }

    /**
     * @param {string} storage
     * @param {string} key
     * @returns {Promise&#x3c;&#x3e;}
     */
    remove(storage, key) { throw &#x27;Not implemented&#x27; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.BaseUpdateFetcher" id="apidoc.element.telegram-node-bot.BaseUpdateFetcher">
        function <span class="apidocSignatureSpan">telegram-node-bot.</span>BaseUpdateFetcher
        <span class="apidocSignatureSpan">(api, logger)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class BaseUpdateFetcher {
<span class="apidocCodeCommentSpan">    /**
     * @param {TelegramApi} api
     * @param {BaseLogger} logger
     */
</span>    constructor(api, logger) {
        this._api = api
        this._logger = logger
    }

    /**
     * @callback fetchUpdatesCallback
     * @param {Update[]} updates
     */

    /**
     * @param {fetchUpdatesCallback} callback
     */
    fetch(callback) { throw &#x27;Not implemented&#x27; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.InlineScope" id="apidoc.element.telegram-node-bot.InlineScope">
        function <span class="apidocSignatureSpan">telegram-node-bot.</span>InlineScope
        <span class="apidocSignatureSpan">(update, api, waitingChosenResults, waitingQueries)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineScope {
<span class="apidocCodeCommentSpan">    /**
     *
     * @param {Update} update
     * @param {TelegramApi} api
     */
</span>    constructor(update, api, waitingChosenResults, waitingQueries) {
        this._update = update
        this._api = api
        this._waitingChosenResults = waitingChosenResults
        this._waitingQueries = waitingQueries
        this._inlineQuery = update.inlineQuery
        this._userId = update.inlineQuery.from.id
    }

    /**
     *
     * @returns {Update}
     */
    get update() {
        return this._update
    }

    /**
     *
     * @returns {TelegramApi}
     */
    get api() {
        return this._api
    }

    /**
     *
     * @returns {InlineQuery}
     */
    get inlineQuery() {
        return this._inlineQuery
    }

    /**
     *
     * @returns {number}
     */
    get userId() {
        return this._userId
    }

    /**
     *
     * @callback answerCallback
     * @param {InlineQueryResult} chosenResult
     */

    /**
     *
     * @param {InlineQueryResult[]} results
     * @param {Object} [options]
     * @param {answerCallback} [callback]
     * @returns Promise&#x3c;boolean&#x3e;
     */
    answer(results, options, callback) {
        results = results.map(result =&#x3e; {
            if (!result.id)
                result._id = Math.random().toString(36).substring(7)

            return result
        })

        this._api.answerInlineQuery(this._inlineQuery.id, results, options)
            .then(() =&#x3e; {
                results.forEach(result =&#x3e; {
                    this._waitingChosenResults[result.id] = () =&#x3e; {
                        callback(result)
                    }
                })
            })
    }

    /**
     *
     * @param {InlineQueryResult[]} results
     * @param {number} answersPerPage
     * @param {answerCallback} callback
     */
    answerPaginated(results, answersPerPage, callback) {
        let slicedData = results.slice(0, answersPerPage)

        this.answer(slicedData, { next_offset: results.length.toString() }, callback)

        this._waitingQueries[this._inlineQuery.query + &#x27;:&#x27; + this._inlineQuery.from.id] = ($) =&#x3e; {
            $.answerPaginated(results.slice(answersPerPage), answersPerPage, callback)
        }
    }

    //api methods starts here

    /**
     *
     * @param {string} text
     * @param {Object} [options]
     * @returns {Promise&#x3c;Message&#x3e;}
     */
    sendMessage(text, options) {
        return this._api.sendMessage(this.userId, text, options)
    }

    /**
     *
     * @param {number} fromChatId
     * @param {number} messageId
     * @param {Object} [options]
     * @returns {Promise&#x3c;Message&#x3e;}
     */
    forwardMessage(fromChatId, messageId, options) {
        return this._api.forwardMessage(this.userId, fromChatId, messageId, options)
    }

    /**
     *
     * @param {InputFile|Object} photo
     * @param {Object} [options]
     * @returns {Promise&#x3c;Message&#x3e;}
     */
    sendPhoto(photo, options) {
        return this._api.sendPhoto(this.userId, photo, options)
    }

    /**
     *
     * @param {InputFile|Object} audio
     * @param {Object} [options]
     * @returns {Promise&#x3c;Message&#x3e;}
     */
    sendAudio(audio, options) {
        return this._api.sendAudio(this.userId, audio, options)
    }

    /**
     *
     * @param {InputFile|Object} document
     * @param {Object} [options]
     * @returns {Promise&#x3c;Message&#x3e;}
     */
    sendDocument(document, options) {
        return this._api.sendDocument(this.userId, document, options)
    }

    /**
     *
     * @param {InputFile|Object} sticker
     * @param {Object} [options]
     * @returns {Promise&#x3c;Message&#x3e;}
     */
    sendSticker(sticker, options) {
        return this._api.sendSticker(this.userId, sticker, options)
    }

    /**
     *
     * @param {InputFile|Object} video
     * @param {Object} [options]
     * @returns {Promise&#x3c;Message&#x3e;}
     */
    sendVideo(video, options) {
        return this._api.sendVideo(this.userId, video, options)
    }

    /**
     *
     * @param {InputFile|Object} voice
     * @param {Object} [options]
     * @returns {Promise&#x3c;Message&#x3e; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.InputFile" id="apidoc.element.telegram-node-bot.InputFile">
        function <span class="apidocSignatureSpan">telegram-node-bot.</span>InputFile
        <span class="apidocSignatureSpan">(fileId, filePath, fileUrl, fileName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InputFile {
<span class="apidocCodeCommentSpan">    /**
     * @param {string|null} fileId
     * @param {string|null} filePath
     * @param {string|null} fileUrl
     * @param {string|null} fileName
     * @private
     */
</span>    constructor(fileId, filePath, fileUrl, fileName) {
        this._fileId = fileId
        this._filePath = filePath
        this._fileUrl = fileUrl
        this._fileName = fileName
    }

    /**
     *
     * @param {string} type
     * @param {Object} params
     * @returns {Promise&#x3c;Object&#x3e;}
     */
    prepareRequest(type, params) {
        return new Promise((resolve) =&#x3e; {
            if (this._fileId) {
                params[type] = this._fileId

                resolve({ params: params, multipart: null })
            }

            if (this._fileUrl) {
                const filePath = __dirname + &#x27;/temp/&#x27; + Math.random().toString(36).substring(7) + &#x27;.dat&#x27;
                const wstream = fs.createWriteStream(filePath)

                const sendedCallback = () =&#x3e; {
                    fs.unlink(filePath)
                }

                wstream.on(&#x27;finish&#x27;, () =&#x3e; {
                    const multipart = { }

                    multipart[type] = {
                        value: fs.createReadStream(filePath),
                        filename: this._fileName || STANDARD_TYPES[type].filename,
                        contentType: STANDARD_TYPES[type].type
                    }

                    resolve({ params: params, multipart: multipart, callback: sendedCallback})
                })

                req.get({
                    url: this._fileUrl,
                    pipe: wstream
                })
            }

            if (this._filePath) {
                const multipart = { }

                multipart[type] = {
                    value: fs.createReadStream(this._filePath),
                    filename: path.basename(this._filePath) || STANDARD_TYPES[type].filename,
                    contentType: STANDARD_TYPES[type].type
                }

                resolve({ params: params, multipart: multipart })
            }
        })
    }

    /**
     * Creates InputFile from plain Object
     *
     * @param {Object|string} raw
     * @returns {InputFile}
     */
    static deserialize(raw) {
        if (typeof raw == &#x27;string&#x27;) {
            return InputFile.byId(raw)
        }

        if (raw.url) {
            return InputFile.byUrl(raw.url, raw.filename)
        }

        if (raw.path) {
            return InputFile.byFilePath(raw.path)
        }
    }

    /**
     * Creates InputFile by file id
     *
     * @param {string} id
     * @returns {InputFile}
     */
    static byId(id) {
        return new InputFile(id, null, null, null)
    }

    /**
     * Creates InputFile by file path
     *
     * @param {string} path
     * @returns {InputFile}
     */
    static byFilePath(path) {
        return new InputFile(null, path, null, null)
    }

    /**
     * Creates InputFile by url
     *
     * @param {string} url
     * @param {string} [fileName]
     * @returns {InputFile}
     */
    static byUrl(url, fileName) {
        return new InputFile(null, null, url, fileName)
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.RegexpCommand" id="apidoc.element.telegram-node-bot.RegexpCommand">
        function <span class="apidocSignatureSpan">telegram-node-bot.</span>RegexpCommand
        <span class="apidocSignatureSpan">(regexp, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class RegexpCommand extends BaseCommand {
<span class="apidocCodeCommentSpan">    /**
     * @param {RegExp} regexp
     * @param {string} [handler]
     */
</span>    constructor(regexp, handler) {
        super()
        this._regexp = regexp
        this._handler = handler
    }

    /**
     * @param {Scope} scope
     * @returns {boolean}
     */
    test(scope) {
        return scope.message.text &#x26;&#x26; this._regexp.test(scope.message.text)
    }

    /**
     * @returns {string}
     */
    get handlerName() {
        return this._handler
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Scope" id="apidoc.element.telegram-node-bot.Scope">
        function <span class="apidocSignatureSpan">telegram-node-bot.</span>Scope
        <span class="apidocSignatureSpan">( update, api, extensions, waitingRequests, waitingCallbackQueries, logger, sessionStorage, waitForUpdate, waitForCallback )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Scope {
<span class="apidocCodeCommentSpan">    /**
     *
     * @param {Update} update
     * @param {TelegramApi} api
     * @param {BaseScopeExtension[]} extensions
     * @param {Function[]} waitingRequests
     * @param {Object} waitingCallbackQueries
     * @param {BaseLogger} logger
     * @param {Function} processUpdate
     * @param {TelegramSessionStorage} sessionStorage
     * @param {Function} waitForUpdate
     * @param {Function} waitForCallback
     */
</span>    constructor( update, api, extensions, waitingRequests, waitingCallbackQueries, logger, sessionStorage, waitForUpdate, waitForCallback ) {
        this._api = api
        this._update = update
        /**
         *
         * @type {BaseScopeExtension[]}
         * @private
         */
        this._extensions = extensions
        this._waitingRequests = waitingRequests
        this._waitingCallbackQueries = waitingCallbackQueries

        this._isEditedMessage = update.editedMessage ? true : false

        this._message = update.message || update.editedMessage
        this._chatId = this._message.chat.id
        this._userId = this._message.from.id
        this._fromGroupChat = !(this._userId === this._chatId)

        this._logger = logger
        this._sessionStorage = sessionStorage
        this._waitForUpdate = waitForUpdate
        this._waitForCallback = waitForCallback

        this._extensions.forEach(extension =&#x3e; {
            const extensionInstance = new extension(this)
            this[extensionInstance.name] = extensionInstance.process
        })
    }

    /**
     * @returns {TelegramSessionStorage}
     */
    get sessionStorage() {
        return this._sessionStorage
    }

    /**
     * @returns {BaseStorage}
     */
    get storage() {
        return this._sessionStorage
    }

    /**
     *
     * @returns {Update}
     */
    get update() {
        return this._update
    }

    /**
     *
     * @returns {Message}
     */
    get message() {
        return this._message
    }

    /**
     *
     * @returns {number}
     */
    get chatId() {
        return this._chatId
    }

    /**
     *
     * @returns {number}
     */
    get userId() {
        return this._userId
    }

    /**
     *
     * @returns {boolean}
     */
    get idFromGroupChat() {
        return this._fromGroupChat
    }

    /**
     *
     * @returns {TelegramApi}
     */
    get api() {
        return this._api
    }

    /**
     * @param {string} key
     * @returns {Promise.&#x3c;*&#x3e;}
     */
    getUserSession(key) {
        return this._sessionStorage.getUserSession(this.userId, key)
    }

    /**
     * @param {string} key
     * @param {*} value
     * @returns {Promise}
     */
    setUserSession(key, value) {
        return this._sessionStorage.setUserSession(this.userId, key, value)
    }

    /**
     * @param {string} key
     * @returns {Promise.&#x3c;*&#x3e;}
     */
    getChatSession(key) {
        return this._sessionStorage.getChatSession(this.chatId, key)
    }

    /**
     * @param {string} key
     * @param {*} value
     * @returns {Promise}
     */
    setChatSession(key, value) {
        return this._sessionStorage.setChatSession(this.chatId, key, value)
    }

    /**
     *
     * @returns {BaseLogger}
     */
    get logger() {
        return this._logger
    }

    /**
     *
     * @returns {boolean}
     */
    get isEditedMessage() {
        return this._isEditedMessage
    }

    /**
     * After calling this the next update
     * from current user will be passed to promise
     *
     * @returns {Promise&#x3c;Scope&#x3e;}
     */
    get waitForRequest() {
        return new Promise(resolve =&#x3e; {
            this._waitingRequests[this.chatId] = resolve
            this._waitForUpdate(this.chatId)
        })
    }

    /**
     * @callback waitForCallbackQueryCallback
     * @param {CallbackQuery} query
     */

    /**
     * If you send some inline keyboard after that you can call this method,
     * pass to it string callback data or array of string or your InlineKeyboardMarkup
     * and then whe ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Telegram" id="apidoc.element.telegram-node-bot.Telegram">
        function <span class="apidocSignatureSpan">telegram-node-bot.</span>Telegram
        <span class="apidocSignatureSpan">(token, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Telegram {
<span class="apidocCodeCommentSpan">    /**
     *
     * @param {string} token
     * @param {{
     * logger: BaseLogger,
     * storage: BaseStorage,
     * localization: Object[],
     * workers: number,
     * webhook: {url: string, port: number, host: string }
     * updateFetcher: BaseUpdateFetcher
     * webAdmin: {port: number, host: string}
     * }} options
     */
</span>    constructor(token, options) {
        options = options || {}

        this._token = token
        this._logger = options.logger || new WebAdminLogger()
        this._storage = options.storage || new InMemoryStorage()
        this._sharedStorage = new SharedStorage(this._storage)
        this._localization = new Ivan(this._sharedStorage, (options.localization || []))
        this._webAdminPort = options.webAdmin ? options.webAdmin.port : 7777
        this._webAdminHost = options.webAdmin ? options.webAdmin.host : &#x27;localhost&#x27;

        this._cpus = os.cpus()
        this._workersCount = options.workers || this._cpus.length

        this._ipc = new TelegramIPC()

        this._telegramDataSource = new TelegramDataSource(
            new TelegramApi(token, this._logger),
            new TelegramRouter(),
            this._logger,
            new TelegramSessionStorage(this._sharedStorage),
            this._localization,
            this._ipc
        )

        this._beforeUpdateFunction = null

        this._checkNodeVersion()

        this._updatesFetcher = null

        if (options.updateFetcher)
            this._updatesFetcher = options.updateFetcher
        else if (options.webhook) {
            this._updatesFetcher = new WebhookUpdateFetcher(
                this._telegramDataSource.api,
                this._logger,
                options.webhook.url,
                options.webhook.host,
                options.webhook.port,
                token
            )
        }
        else {
            this._updatesFetcher = new LongPoolingUpdateFetcher(
                this._telegramDataSource.api,
                this._logger
            )
        }

        this._setup()
    }

    _checkNodeVersion() {
        if (process.version.replace(&#x27;v&#x27;, &#x27;&#x27;).split(&#x27;.&#x27;)[0] &#x3c; 6) {
            this._logger.error({
                &#x27;Fatal error&#x27;: &#x27;Node version must be 6 or greater, please update your Node.js&#x27;
            })

            process.exit()
        }
    }

    _setup() {
        if (cluster.isMaster)
            this._master()

        if (cluster.isWorker)
            this._worker()
    }

    _master() {
        this._logger.log({
            &#x27;Telegram&#x27;: `Master started, ${this._cpus.length} CPUs found, ${this._workersCount} workers will start`
        })

        this._waitingUpdates = {} // each worker can ask master to send him next update from specific chat
        this._waitingCallbacks = {}
        this._workers = {}
        this.statistics = new Statistics()

        new WebAdmin(
            this._webAdminHost,
            this._webAdminPort,
            __dirname + &#x27;/webAdmin/client&#x27;,
            this._logger,
            this
        )

        this._runWorkers()

        this._updatesFetcher.fetch(updates =&#x3e; {
            this._processUpdates(updates)
        })
    }

    _worker() {
        this._updateProcessor = new UpdateProcessorsManager(this._telegramDataSource)

        process.on(&#x27;message&#x27;, msg =&#x3e; {
            if (msg.type == &#x27;update&#x27;) {
                this._processUpdates([Update.deserialize(msg.update)])
                return
            }

            this._sharedStorage.handleMessageFromMaster(msg)
        })
    }

    _fork() {
        return cluster.fork()
    }

    restartWorkers() {
        this._logger.log({ &#x27;Telegram&#x27;: &#x27;restarting workers&#x27; })

        for (const pid in this._workers) {
            if (this._workers[pid])
                this._workers[pid].kill()
        }
    }

    /**
     * This callback will be called from master process
     *
     * @param {Function} callback
     */
    onMaster(callback) {
        if (cluster.isMaster)
            callback()
    }

    _runWorkers() {
        for(var i = 0; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
&#x27;use strict&#x27;

const Telegram = require(&#x27;telegram-node-bot&#x27;)
const TelegramBaseController = Telegram.TelegramBaseController
const TextCommand = Telegram.TextCommand
const tg = new Telegram.<span class="apidocCodeKeywordSpan">Telegram</span>(&#x27;YOUR_TOKEN&#x27;)

class PingController extends TelegramBaseController {
/**
 * @param {Scope} $
 */
pingHandler($) {
    $.sendMessage(&#x27;pong&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.TelegramApi" id="apidoc.element.telegram-node-bot.TelegramApi">
        function <span class="apidocSignatureSpan">telegram-node-bot.</span>TelegramApi
        <span class="apidocSignatureSpan">(token, logger)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class TelegramApi {
<span class="apidocCodeCommentSpan">    /**
     *
     * @param {string} token
     * @param {BaseLogger} logger
     */
</span>    constructor(token, logger) {
        this._token = token
        this._url = `https://api.telegram.org/bot${this._token}/`
        this._queue = new CallbackQueue(REQUESTS_PER_SECOND)
        this._logger = logger
    }

    /**
     *
     * @param {string} method
     * @returns {string}
     * @private
     */
    _urlForMethod(method) {
        return this._url + method
    }

    /**
     *
     * @param {string} method
     * @param {object} params
     * @param {object} [multipart]
     * @returns {Promise&#x3c;Object&#x3e;}
     */
    call(method, params, multipart) {
        return new Promise((resolve, reject) =&#x3e; {
            const request = new TelegramApiRequest(method, params, multipart)

            this._queue.push(() =&#x3e; {
                this._handleRequest(request, resolve, reject)
            })
        })
    }

    /**
     *
     * @param {string} method
     * @param {Object} params
     * @param {function} type
     * @param {object} [multipart]
     * @returns {Promise}
     * @private
     */
    _callWithReturnType(method, params, type, multipart) {
        return this.call(method, params, multipart)
            .then(response =&#x3e; {
                return type.deserialize(response.result)
            })
    }

    /**
     *
     * @param {TelegramApiRequest }request
     * @param {function} resolve
     * @param {function} reject
     * @private
     */
    _handleRequest(request, resolve, reject) {
        req.post({
            url: this._urlForMethod(request.method),
            form: request.multipart ? null : request.params,
            query: request.multipart ? request.params : null,
            multipart: request.multipart,
            json: true
        }, (body, response, err) =&#x3e; {
            if (!err &#x26;&#x26; response.statusCode == 200 &#x26;&#x26; body) {
                resolve(body)
                return
            }

            if (err &#x26;&#x26; err.code) {
                this._logger.error({&#x27;Network error:&#x27;: err, &#x27;request&#x27;: request })
                this._retryRequest(request, resolve, reject)

                return
            }

            if (body &#x26;&#x26; body.error_code) {
                const error = TelegramApiError.fromResponse(body)

                if (error.code == 500) {
                    this._logger.warn({ &#x27;Got Internal server error from Telegram. Body:&#x27;: body })
                    this._retryRequest(request, resolve, reject)

                    return
                }

                reject(error)
                this._logger.warn({ &#x27;Api error: Body:&#x27;: body })

                return
            }

            if (err.message === &#x27;Unexpected token &#x3c; in JSON at position 0&#x27;) {
                this._logger.error({
                    &#x27;api request error: Telegram returned some html instead of json. Body:&#x27;: body,
                    &#x27;Error:&#x27;: err
                })
                this._retryRequest(request, resolve, reject)

                return
            }

            this._logger.error({&#x27;api request error: Body:&#x27;: body, &#x27;Error:&#x27;: err })
            reject(err)
        })
    }

    /**
     *
     * @param {TelegramApiRequest }request
     * @param {function} resolve
     * @param {function} reject
     * @private
     */
    _retryRequest(request, resolve, reject) {
        setTimeout(() =&#x3e; {
            this._queue.push(() =&#x3e; {
                this._logger.log({ &#x27;Retry request&#x27;: request })
                this._handleRequest(request, resolve, reject)
            })
        }, REQUEST_RETRY_TIMEOUT)
    }

    /**
     *
     * @param {string} method
     * @param {InputFile|Object} inputFile
     * @param {string} type
     * @param {Object} params
     * @returns {Promise}
     * @private
     */
    _callWithInputFile(method, inputFile, type, params) {
        const file = inputFile instanceof InputFile ? inputFile : InputFile.deserialize(inputFile)
        let sentCallback = Function()

        return file.prepareRequest(type, params)
            .then(prepared =&#x3e;  { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.TelegramBaseCallbackQueryController" id="apidoc.element.telegram-node-bot.TelegramBaseCallbackQueryController">
        function <span class="apidocSignatureSpan">telegram-node-bot.</span>TelegramBaseCallbackQueryController
        <span class="apidocSignatureSpan">(query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class TelegramBaseCallbackQueryController {
<span class="apidocCodeCommentSpan">    /**
     * This method of your controller will be called to handle callbackQuery.
     *
     * @param {CallbackQuery} query
     */
</span>    handle(query) { throw &#x27;Not implemented&#x27; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.TelegramBaseController" id="apidoc.element.telegram-node-bot.TelegramBaseController">
        function <span class="apidocSignatureSpan">telegram-node-bot.</span>TelegramBaseController
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class TelegramBaseController {
    constructor() {
        this._api = null
        this._localization = null
    }

<span class="apidocCodeCommentSpan">    /**
     * This method of your controller will be called to handle command.
     *
     * @param {Scope} scope
     */
</span>    handle(scope) { throw &#x27;Not implemented&#x27; }

    /**
     * If you want a specific methods of your controller be called for specific commands,
     * you should return here an plain object where key is a route and value is name of your method.
     * In that case handle method will not be called and scope will be passed to your method.
     * Return example: { &#x27;/start&#x27;: &#x27;startMethod&#x27; }
     *
     * @returns {Object}
     */
    get routes() { return {} }

    /**
     * This method will be called before any command handler or handle method.
     * You can modify incoming scope and must return it.
     * Your modified scope will be passed to controller.
     *
     * @param {Scope} scope
     * @returns {Scope}
     */
    before(scope) { return scope }

    /**
     *
     * @param {TelegramApi} api
     */
    set api(api) {
        this._api = api
    }

    /**
     *
     * @param {Ivan} localization
     */
    set localization(localization) {
        this._localization = localization
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.TelegramBaseInlineQueryController" id="apidoc.element.telegram-node-bot.TelegramBaseInlineQueryController">
        function <span class="apidocSignatureSpan">telegram-node-bot.</span>TelegramBaseInlineQueryController
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class TelegramBaseInlineQueryController {
    constructor() {
        this._api = null
        this._localization = null
    }

<span class="apidocCodeCommentSpan">    /**
     * This method of your controller will be called to handle inline query.
     *
     * @param {InlineScope} scope
     */
</span>    handle(scope) { throw &#x27;Not implemented&#x27; }

    /**
     *
     * @param {ChosenInlineResult} result
     */
    chosenResult(result) { }

    /**
     *
     * @param {TelegramApi} api
     */
    set api(api) {
        this._api = api
    }

    /**
     *
     * @param {Ivan} localization
     */
    set localization(localization) {
        this._localization = localization
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.TextCommand" id="apidoc.element.telegram-node-bot.TextCommand">
        function <span class="apidocSignatureSpan">telegram-node-bot.</span>TextCommand
        <span class="apidocSignatureSpan">(textPattern, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class TextCommand extends BaseCommand {
<span class="apidocCodeCommentSpan">    /**
     * @param {string} textPattern
     * @param {string} [handler]
     */
</span>    constructor(textPattern, handler) {
        super()
        this._textPattern = textPattern
        this._handler = handler
    }

    /**
     * @param {Scope} scope
     * @returns {boolean}
     */
    test(scope) {
        return scope.message.text &#x26;&#x26;
            scope.message.text.indexOf(this._textPattern) &#x3e; -1
    }

    /**
     * @returns {string}
     */
    get handlerName() {
        return this._handler
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.telegram-node-bot.Models" id="apidoc.module.telegram-node-bot.Models">module telegram-node-bot.Models</a></h1>


    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.Animation" id="apidoc.element.telegram-node-bot.Models.Animation">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Animation
        <span class="apidocSignatureSpan">(fileId, thumb, fileName, mimeType, fileSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Animation {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} fileId
    * @param {PhotoSize|null} [thumb]
    * @param {string|null} [fileName]
    * @param {string|null} [mimeType]
    * @param {number|null} [fileSize]
   */
</span>   constructor(fileId, thumb, fileName, mimeType, fileSize) {
       this._fileId = fileId
       this._thumb = thumb
       this._fileName = fileName
       this._mimeType = mimeType
       this._fileSize = fileSize
   }

   /**
    * Unique file identifier
    * @returns {string}
   */
   get fileId() {
       return this._fileId
   }

   /**
    * Animation thumbnail as defined by sender
    * @returns {PhotoSize|null}
   */
   get thumb() {
       return this._thumb
   }

   /**
    * Original animation filename as defined by sender
    * @returns {string|null}
   */
   get fileName() {
       return this._fileName
   }

   /**
    * MIME type of the file as defined by sender
    * @returns {string|null}
   */
   get mimeType() {
       return this._mimeType
   }

   /**
    * File size
    * @returns {number|null}
   */
   get fileSize() {
       return this._fileSize
   }

   /**
    *
    * @param {Object} raw
    * @returns {Animation}
    */
   static deserialize(raw) {
      return new Animation(
          raw[&#x27;file_id&#x27;],
          raw[&#x27;thumb&#x27;] ? PhotoSize.deserialize(raw[&#x27;thumb&#x27;]) : null,
          raw[&#x27;file_name&#x27;] ? raw[&#x27;file_name&#x27;] : null,
          raw[&#x27;mime_type&#x27;] ? raw[&#x27;mime_type&#x27;] : null,
          raw[&#x27;file_size&#x27;] ? raw[&#x27;file_size&#x27;] : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          file_id: this.fileId ? this.fileId : undefined,
          thumb: this.thumb ? this.thumb.serialize() : undefined,
          file_name: this.fileName ? this.fileName : undefined,
          mime_type: this.mimeType ? this.mimeType : undefined,
          file_size: this.fileSize ? this.fileSize : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.Audio" id="apidoc.element.telegram-node-bot.Models.Audio">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Audio
        <span class="apidocSignatureSpan">(fileId, duration, performer, title, mimeType, fileSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Audio {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} fileId
    * @param {number} duration
    * @param {string|null} [performer]
    * @param {string|null} [title]
    * @param {string|null} [mimeType]
    * @param {number|null} [fileSize]
   */
</span>   constructor(fileId, duration, performer, title, mimeType, fileSize) {
       this._fileId = fileId
       this._duration = duration
       this._performer = performer
       this._title = title
       this._mimeType = mimeType
       this._fileSize = fileSize
   }

   /**
    * Unique identifier for this file
    * @returns {string}
   */
   get fileId() {
       return this._fileId
   }

   /**
    * Duration of the audio in seconds as defined by sender
    * @returns {number}
   */
   get duration() {
       return this._duration
   }

   /**
    * Performer of the audio as defined by sender or by audio tags
    * @returns {string|null}
   */
   get performer() {
       return this._performer
   }

   /**
    * Title of the audio as defined by sender or by audio tags
    * @returns {string|null}
   */
   get title() {
       return this._title
   }

   /**
    * MIME type of the file as defined by sender
    * @returns {string|null}
   */
   get mimeType() {
       return this._mimeType
   }

   /**
    * File size
    * @returns {number|null}
   */
   get fileSize() {
       return this._fileSize
   }

   /**
    *
    * @param {Object} raw
    * @returns {Audio}
    */
   static deserialize(raw) {
      return new Audio(
          raw[&#x27;file_id&#x27;],
          raw[&#x27;duration&#x27;],
          raw[&#x27;performer&#x27;] ? raw[&#x27;performer&#x27;] : null,
          raw[&#x27;title&#x27;] ? raw[&#x27;title&#x27;] : null,
          raw[&#x27;mime_type&#x27;] ? raw[&#x27;mime_type&#x27;] : null,
          raw[&#x27;file_size&#x27;] ? raw[&#x27;file_size&#x27;] : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          file_id: this.fileId ? this.fileId : undefined,
          duration: this.duration ? this.duration : undefined,
          performer: this.performer ? this.performer : undefined,
          title: this.title ? this.title : undefined,
          mime_type: this.mimeType ? this.mimeType : undefined,
          file_size: this.fileSize ? this.fileSize : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.CallbackQuery" id="apidoc.element.telegram-node-bot.Models.CallbackQuery">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>CallbackQuery
        <span class="apidocSignatureSpan">( id, from, message, inlineMessageId, chatInstance, data, gameShortName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class CallbackQuery {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} id
    * @param {User} from
    * @param {Message|null} [message]
    * @param {string|null} [inlineMessageId]
    * @param {string} chatInstance
    * @param {string|null} [data]
    * @param {string|null} [gameShortName]
   */
</span>   constructor( id, from, message, inlineMessageId, chatInstance, data, gameShortName ) {
       this._id = id
       this._from = from
       this._message = message
       this._inlineMessageId = inlineMessageId
       this._chatInstance = chatInstance
       this._data = data
       this._gameShortName = gameShortName
   }

   /**
    * Unique identifier for this query
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * Sender
    * @returns {User}
   */
   get from() {
       return this._from
   }

   /**
    * Message with the callback button that originated the query. Note that message content and message date will not be available
 if the message is too old
    * @returns {Message|null}
   */
   get message() {
       return this._message
   }

   /**
    * Identifier of the message sent via the bot in inline mode, that originated the query.
    * @returns {string|null}
   */
   get inlineMessageId() {
       return this._inlineMessageId
   }

   /**
    * Global identifier, uniquely corresponding to the chat to which the message with the callback button was sent. Useful for high
 scores in games.
    * @returns {string}
   */
   get chatInstance() {
       return this._chatInstance
   }

   /**
    * Data associated with the callback button. Be aware that a bad client can send arbitrary data in this field.
    * @returns {string|null}
   */
   get data() {
       return this._data
   }

   /**
    * Short name of a Game to be returned, serves as the unique identifier for the game
    * @returns {string|null}
   */
   get gameShortName() {
       return this._gameShortName
   }

   /**
    *
    * @param {Object} raw
    * @returns {CallbackQuery}
    */
   static deserialize(raw) {
      return new CallbackQuery(
          raw[&#x27;id&#x27;],
          raw[&#x27;from&#x27;] ? User.deserialize(raw[&#x27;from&#x27;]) : null,
          raw[&#x27;message&#x27;] ? Message.deserialize(raw[&#x27;message&#x27;]) : null,
          raw[&#x27;inline_message_id&#x27;] ? raw[&#x27;inline_message_id&#x27;] : null,
          raw[&#x27;chat_instance&#x27;],
          raw[&#x27;data&#x27;] ? raw[&#x27;data&#x27;] : null,
          raw[&#x27;game_short_name&#x27;] ? raw[&#x27;game_short_name&#x27;] : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          id: this.id ? this.id : undefined,
          from: this.from ? this.from.serialize() : undefined,
          message: this.message ? this.message.serialize() : undefined,
          inline_message_id: this.inlineMessageId ? this.inlineMessageId : undefined,
          chat_instance: this.chatInstance ? this.chatInstance : undefined,
          data: this.data ? this.data : undefined,
          game_short_name: this.gameShortName ? this.gameShortName : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.Chat" id="apidoc.element.telegram-node-bot.Models.Chat">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Chat
        <span class="apidocSignatureSpan">( id, type, title, username, firstName, lastName, allMembersAreAdministrators )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Chat {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {number} id
    * @param {string} type
    * @param {string|null} [title]
    * @param {string|null} [username]
    * @param {string|null} [firstName]
    * @param {string|null} [lastName]
    * @param {boolean|null} [allMembersAreAdministrators]
   */
</span>   constructor( id, type, title, username, firstName, lastName, allMembersAreAdministrators ) {
       this._id = id
       this._type = type
       this._title = title
       this._username = username
       this._firstName = firstName
       this._lastName = lastName
       this._allMembersAreAdministrators = allMembersAreAdministrators
   }

   /**
    * Unique identifier for this chat. This number may be greater than 32 bits and some programming languages may have difficulty
/silent defects in interpreting it. But it smaller than 52 bits, so a signed 64 bit integer or double-precision float type are safe
 for storing this identifier.
    * @returns {number}
   */
   get id() {
       return this._id
   }

   /**
    * Type of chat, can be either private, group, supergroup or channel
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Title, for supergroups, channels and group chats
    * @returns {string|null}
   */
   get title() {
       return this._title
   }

   /**
    * Username, for private chats, supergroups and channels if available
    * @returns {string|null}
   */
   get username() {
       return this._username
   }

   /**
    * First name of the other party in a private chat
    * @returns {string|null}
   */
   get firstName() {
       return this._firstName
   }

   /**
    * Last name of the other party in a private chat
    * @returns {string|null}
   */
   get lastName() {
       return this._lastName
   }

   /**
    * True if a group has All Members Are Admins enabled.
    * @returns {boolean|null}
   */
   get allMembersAreAdministrators() {
       return this._allMembersAreAdministrators
   }

   /**
    *
    * @param {Object} raw
    * @returns {Chat}
    */
   static deserialize(raw) {
      return new Chat(
          raw[&#x27;id&#x27;],
          raw[&#x27;type&#x27;],
          raw[&#x27;title&#x27;] ? raw[&#x27;title&#x27;] : null,
          raw[&#x27;username&#x27;] ? raw[&#x27;username&#x27;] : null,
          raw[&#x27;first_name&#x27;] ? raw[&#x27;first_name&#x27;] : null,
          raw[&#x27;last_name&#x27;] ? raw[&#x27;last_name&#x27;] : null,
          raw[&#x27;all_members_are_administrators&#x27;] ? raw[&#x27;all_members_are_administrators&#x27;] : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          id: this.id ? this.id : undefined,
          type: this.type ? this.type : undefined,
          title: this.title ? this.title : undefined,
          username: this.username ? this.username : undefined,
          first_name: this.firstName ? this.firstName : undefined,
          last_name: this.lastName ? this.lastName : undefined,
          all_members_are_administrators: this.allMembersAreAdministrators ? this.allMembersAreAdministrators : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.ChatMember" id="apidoc.element.telegram-node-bot.Models.ChatMember">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>ChatMember
        <span class="apidocSignatureSpan">(user, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ChatMember {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {User} user
    * @param {string} status
   */
</span>   constructor(user, status) {
       this._user = user
       this._status = status
   }

   /**
    * Information about the user
    * @returns {User}
   */
   get user() {
       return this._user
   }

   /**
    * The member&#x27;s status in the chat. Can be creator, administrator, member, left or kicked
    * @returns {string}
   */
   get status() {
       return this._status
   }

   /**
    *
    * @param {Object} raw
    * @returns {ChatMember}
    */
   static deserialize(raw) {
      return new ChatMember(raw[&#x27;user&#x27;] ? User.deserialize(raw[&#x27;user&#x27;]) : null, raw[&#x27;status&#x27;])
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          user: this.user ? this.user.serialize() : undefined,
          status: this.status ? this.status : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.ChosenInlineResult" id="apidoc.element.telegram-node-bot.Models.ChosenInlineResult">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>ChosenInlineResult
        <span class="apidocSignatureSpan">(resultId, from, location, inlineMessageId, query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ChosenInlineResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} resultId
    * @param {User} from
    * @param {Location|null} [location]
    * @param {string|null} [inlineMessageId]
    * @param {string} query
   */
</span>   constructor(resultId, from, location, inlineMessageId, query) {
       this._resultId = resultId
       this._from = from
       this._location = location
       this._inlineMessageId = inlineMessageId
       this._query = query
   }

   /**
    * The unique identifier for the result that was chosen
    * @returns {string}
   */
   get resultId() {
       return this._resultId
   }

   /**
    * The user that chose the result
    * @returns {User}
   */
   get from() {
       return this._from
   }

   /**
    * Sender location, only for bots that require user location
    * @returns {Location|null}
   */
   get location() {
       return this._location
   }

   /**
    * Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message. Will be also
 received in callback queries and can be used to edit the message.
    * @returns {string|null}
   */
   get inlineMessageId() {
       return this._inlineMessageId
   }

   /**
    * The query that was used to obtain the result
    * @returns {string}
   */
   get query() {
       return this._query
   }

   /**
    *
    * @param {Object} raw
    * @returns {ChosenInlineResult}
    */
   static deserialize(raw) {
      return new ChosenInlineResult(
          raw[&#x27;result_id&#x27;],
          raw[&#x27;from&#x27;] ? User.deserialize(raw[&#x27;from&#x27;]) : null,
          raw[&#x27;location&#x27;] ? Location.deserialize(raw[&#x27;location&#x27;]) : null,
          raw[&#x27;inline_message_id&#x27;] ? raw[&#x27;inline_message_id&#x27;] : null,
          raw[&#x27;query&#x27;]
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          result_id: this.resultId ? this.resultId : undefined,
          from: this.from ? this.from.serialize() : undefined,
          location: this.location ? this.location.serialize() : undefined,
          inline_message_id: this.inlineMessageId ? this.inlineMessageId : undefined,
          query: this.query ? this.query : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.Contact" id="apidoc.element.telegram-node-bot.Models.Contact">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Contact
        <span class="apidocSignatureSpan">(phoneNumber, firstName, lastName, userId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Contact {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} phoneNumber
    * @param {string} firstName
    * @param {string|null} [lastName]
    * @param {number|null} [userId]
   */
</span>   constructor(phoneNumber, firstName, lastName, userId) {
       this._phoneNumber = phoneNumber
       this._firstName = firstName
       this._lastName = lastName
       this._userId = userId
   }

   /**
    * Contact&#x27;s phone number
    * @returns {string}
   */
   get phoneNumber() {
       return this._phoneNumber
   }

   /**
    * Contact&#x27;s first name
    * @returns {string}
   */
   get firstName() {
       return this._firstName
   }

   /**
    * Contact&#x27;s last name
    * @returns {string|null}
   */
   get lastName() {
       return this._lastName
   }

   /**
    * Contact&#x27;s user identifier in Telegram
    * @returns {number|null}
   */
   get userId() {
       return this._userId
   }

   /**
    *
    * @param {Object} raw
    * @returns {Contact}
    */
   static deserialize(raw) {
      return new Contact(raw[&#x27;phone_number&#x27;], raw[&#x27;first_name&#x27;], raw[&#x27;last_name&#x27;] ? raw[&#x27;last_name&#x27;] : null, raw[&#x27;user_id&#x27;] ? raw
[&#x27;user_id&#x27;] : null)
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          phone_number: this.phoneNumber ? this.phoneNumber : undefined,
          first_name: this.firstName ? this.firstName : undefined,
          last_name: this.lastName ? this.lastName : undefined,
          user_id: this.userId ? this.userId : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.Document" id="apidoc.element.telegram-node-bot.Models.Document">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Document
        <span class="apidocSignatureSpan">(fileId, thumb, fileName, mimeType, fileSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Document {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} fileId
    * @param {PhotoSize|null} [thumb]
    * @param {string|null} [fileName]
    * @param {string|null} [mimeType]
    * @param {number|null} [fileSize]
   */
</span>   constructor(fileId, thumb, fileName, mimeType, fileSize) {
       this._fileId = fileId
       this._thumb = thumb
       this._fileName = fileName
       this._mimeType = mimeType
       this._fileSize = fileSize
   }

   /**
    * Unique file identifier
    * @returns {string}
   */
   get fileId() {
       return this._fileId
   }

   /**
    * Document thumbnail as defined by sender
    * @returns {PhotoSize|null}
   */
   get thumb() {
       return this._thumb
   }

   /**
    * Original filename as defined by sender
    * @returns {string|null}
   */
   get fileName() {
       return this._fileName
   }

   /**
    * MIME type of the file as defined by sender
    * @returns {string|null}
   */
   get mimeType() {
       return this._mimeType
   }

   /**
    * File size
    * @returns {number|null}
   */
   get fileSize() {
       return this._fileSize
   }

   /**
    *
    * @param {Object} raw
    * @returns {Document}
    */
   static deserialize(raw) {
      return new Document(
          raw[&#x27;file_id&#x27;],
          raw[&#x27;thumb&#x27;] ? PhotoSize.deserialize(raw[&#x27;thumb&#x27;]) : null,
          raw[&#x27;file_name&#x27;] ? raw[&#x27;file_name&#x27;] : null,
          raw[&#x27;mime_type&#x27;] ? raw[&#x27;mime_type&#x27;] : null,
          raw[&#x27;file_size&#x27;] ? raw[&#x27;file_size&#x27;] : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          file_id: this.fileId ? this.fileId : undefined,
          thumb: this.thumb ? this.thumb.serialize() : undefined,
          file_name: this.fileName ? this.fileName : undefined,
          mime_type: this.mimeType ? this.mimeType : undefined,
          file_size: this.fileSize ? this.fileSize : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.File" id="apidoc.element.telegram-node-bot.Models.File">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>File
        <span class="apidocSignatureSpan">(fileId, fileSize, filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class File {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} fileId
    * @param {number|null} [fileSize]
    * @param {string|null} [filePath]
   */
</span>   constructor(fileId, fileSize, filePath) {
       this._fileId = fileId
       this._fileSize = fileSize
       this._filePath = filePath
   }

   /**
    * Unique identifier for this file
    * @returns {string}
   */
   get fileId() {
       return this._fileId
   }

   /**
    * File size, if known
    * @returns {number|null}
   */
   get fileSize() {
       return this._fileSize
   }

   /**
    * File path. Use https://api.telegram.org/file/bot&#x3c;token&#x3e;/&#x3c;file_path&#x3e; to get the file.
    * @returns {string|null}
   */
   get filePath() {
       return this._filePath
   }

   /**
    *
    * @param {Object} raw
    * @returns {File}
    */
   static deserialize(raw) {
      return new File(raw[&#x27;file_id&#x27;], raw[&#x27;file_size&#x27;] ? raw[&#x27;file_size&#x27;] : null, raw[&#x27;file_path&#x27;] ? raw[&#x27;file_path&#x27;] : null)
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          file_id: this.fileId ? this.fileId : undefined,
          file_size: this.fileSize ? this.fileSize : undefined,
          file_path: this.filePath ? this.filePath : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.ForceReply" id="apidoc.element.telegram-node-bot.Models.ForceReply">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>ForceReply
        <span class="apidocSignatureSpan">(forceReply, selective)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ForceReply {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {boolean} forceReply
    * @param {boolean|null} [selective]
   */
</span>   constructor(forceReply, selective) {
       this._forceReply = forceReply
       this._selective = selective
   }

   /**
    * Shows reply interface to the user, as if they manually selected the bots message and tapped Reply&#x27;
    * @returns {boolean}
   */
   get forceReply() {
       return this._forceReply
   }

   /**
    * Use this parameter if you want to force reply from specific users only. Targets: 1) users that are @mentioned in the text
of the Message object; 2) if the bot&#x27;s message is a reply (has reply_to_message_id), sender of the original message.
    * @returns {boolean|null}
   */
   get selective() {
       return this._selective
   }

   /**
    *
    * @param {Object} raw
    * @returns {ForceReply}
    */
   static deserialize(raw) {
      return new ForceReply(raw[&#x27;force_reply&#x27;], raw[&#x27;selective&#x27;] ? raw[&#x27;selective&#x27;] : null)
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          force_reply: this.forceReply ? this.forceReply : undefined,
          selective: this.selective ? this.selective : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.Game" id="apidoc.element.telegram-node-bot.Models.Game">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Game
        <span class="apidocSignatureSpan">(title, description, photo, text, textEntities, animation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Game {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} title
    * @param {string} description
    * @param {PhotoSize[]} photo
    * @param {string|null} [text]
    * @param {MessageEntity[]|null} [textEntities]
    * @param {Animation|null} [animation]
   */
</span>   constructor(title, description, photo, text, textEntities, animation) {
       this._title = title
       this._description = description
       this._photo = photo
       this._text = text
       this._textEntities = textEntities
       this._animation = animation
   }

   /**
    * Title of the game
    * @returns {string}
   */
   get title() {
       return this._title
   }

   /**
    * Description of the game
    * @returns {string}
   */
   get description() {
       return this._description
   }

   /**
    * Photo that will be displayed in the game message in chats.
    * @returns {PhotoSize[]}
   */
   get photo() {
       return this._photo
   }

   /**
    * Brief description of the game or high scores included in the game message. Can be automatically edited to include current
high scores for the game when the bot calls setGameScore, or manually edited using editMessageText. 0-4096 characters.
    * @returns {string|null}
   */
   get text() {
       return this._text
   }

   /**
    * Special entities that appear in text, such as usernames, URLs, bot commands, etc.
    * @returns {MessageEntity[]|null}
   */
   get textEntities() {
       return this._textEntities
   }

   /**
    * Animation that will be displayed in the game message in chats. Upload via BotFather
    * @returns {Animation|null}
   */
   get animation() {
       return this._animation
   }

   /**
    *
    * @param {Object} raw
    * @returns {Game}
    */
   static deserialize(raw) {
      return new Game(
          raw[&#x27;title&#x27;],
          raw[&#x27;description&#x27;],
          raw[&#x27;photo&#x27;] ? raw[&#x27;photo&#x27;].map(item =&#x3e; PhotoSize.deserialize(item)) : null,
          raw[&#x27;text&#x27;] ? raw[&#x27;text&#x27;] : null,
          raw[&#x27;text_entities&#x27;] ? raw[&#x27;text_entities&#x27;].map(item =&#x3e; MessageEntity.deserialize(item)) : null,
          raw[&#x27;animation&#x27;] ? Animation.deserialize(raw[&#x27;animation&#x27;]) : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          title: this.title ? this.title : undefined,
          description: this.description ? this.description : undefined,
          photo: this.photo ? this.photo.map(item =&#x3e; item.serialize()) : undefined,
          text: this.text ? this.text : undefined,
          text_entities: this.textEntities ? this.textEntities.map(item =&#x3e; item.serialize()) : undefined,
          animation: this.animation ? this.animation.serialize() : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.GameHighScore" id="apidoc.element.telegram-node-bot.Models.GameHighScore">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>GameHighScore
        <span class="apidocSignatureSpan">(position, user, score)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class GameHighScore {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {number} position
    * @param {User} user
    * @param {number} score
   */
</span>   constructor(position, user, score) {
       this._position = position
       this._user = user
       this._score = score
   }

   /**
    * Position in high score table for the game
    * @returns {number}
   */
   get position() {
       return this._position
   }

   /**
    * User
    * @returns {User}
   */
   get user() {
       return this._user
   }

   /**
    * Score
    * @returns {number}
   */
   get score() {
       return this._score
   }

   /**
    *
    * @param {Object} raw
    * @returns {GameHighScore}
    */
   static deserialize(raw) {
      return new GameHighScore(raw[&#x27;position&#x27;], raw[&#x27;user&#x27;] ? User.deserialize(raw[&#x27;user&#x27;]) : null, raw[&#x27;score&#x27;])
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          position: this.position ? this.position : undefined,
          user: this.user ? this.user.serialize() : undefined,
          score: this.score ? this.score : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineKeyboardButton" id="apidoc.element.telegram-node-bot.Models.InlineKeyboardButton">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineKeyboardButton
        <span class="apidocSignatureSpan">(text, url, callbackData, switchInlineQuery, switchInlineQueryCurrentChat, callbackGame)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineKeyboardButton {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} text
    * @param {string|null} [url]
    * @param {string|null} [callbackData]
    * @param {string|null} [switchInlineQuery]
    * @param {string|null} [switchInlineQueryCurrentChat]
    * @param {CallbackGame|null} [callbackGame]
   */
</span>   constructor(text, url, callbackData, switchInlineQuery, switchInlineQueryCurrentChat, callbackGame) {
       this._text = text
       this._url = url
       this._callbackData = callbackData
       this._switchInlineQuery = switchInlineQuery
       this._switchInlineQueryCurrentChat = switchInlineQueryCurrentChat
       this._callbackGame = callbackGame
   }

   /**
    * Label text on the button
    * @returns {string}
   */
   get text() {
       return this._text
   }

   /**
    * HTTP url to be opened when button is pressed
    * @returns {string|null}
   */
   get url() {
       return this._url
   }

   /**
    * Data to be sent in a callback query to the bot when button is pressed, 1-64 bytes
    * @returns {string|null}
   */
   get callbackData() {
       return this._callbackData
   }

   /**
    * If set, pressing the button will prompt the user to select one of their chats, open that chat and insert the bots username
 and the specified inline query in the input field. Can be empty, in which case just the bots username will be inserted.Note: This
 offers an easy way for users to start using your bot in inline mode when they are currently in a private chat with it. Especially
 useful when combined with switch_pm actions  in this case the user will be automatically returned to the chat they switched from
, skipping the chat selection screen.
    * @returns {string|null}
   */
   get switchInlineQuery() {
       return this._switchInlineQuery
   }

   /**
    * If set, pressing the button will insert the bots username and the specified inline query in the current chat&#x27;s input field
. Can be empty, in which case only the bots username will be inserted.This offers a quick way for the user to open your bot in
inline mode in the same chat  good for selecting something from multiple options.
    * @returns {string|null}
   */
   get switchInlineQueryCurrentChat() {
       return this._switchInlineQueryCurrentChat
   }

   /**
    * Description of the game that will be launched when the user presses the button.NOTE: This type of button must always be the
 first button in the first row.
    * @returns {CallbackGame|null}
   */
   get callbackGame() {
       return this._callbackGame
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineKeyboardButton}
    */
   static deserialize(raw) {
      return new InlineKeyboardButton(
          raw[&#x27;text&#x27;],
          raw[&#x27;url&#x27;] ? raw[&#x27;url&#x27;] : null,
          raw[&#x27;callback_data&#x27;] ? raw[&#x27;callback_data&#x27;] : null,
          raw[&#x27;switch_inline_query&#x27;] ? raw[&#x27;switch_inline_query&#x27;] : null,
          raw[&#x27;switch_inline_query_current_chat&#x27;] ? raw[&#x27;switch_inline_query_current_chat&#x27;] : null,
          raw[&#x27;callback_game&#x27;] ? CallbackGame.deserialize(raw[&#x27;callback_game&#x27;]) : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          text: this.text ? this.text : undefined,
          url: this.url ? this.url : undefined,
          callback_data: this.callbackData ? this.callbackData : undefined,
          switch_inline_query: this.switchInlineQuery ? this.switchInlineQuery : undefined,
          switch_inline_query_current_chat: this.switchInlineQueryCurrentChat ? this.switchInlineQueryCurrentChat : undefined,
          callback_game: this.callbackGame ? this.callbackGame.serialize() : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineKeyboardMarkup" id="apidoc.element.telegram-node-bot.Models.InlineKeyboardMarkup">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineKeyboardMarkup
        <span class="apidocSignatureSpan">(inlineKeyboard)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineKeyboardMarkup {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {InlineKeyboardButton[][]} inlineKeyboard
   */
</span>   constructor(inlineKeyboard) {
       this._inlineKeyboard = inlineKeyboard
   }

   /**
    * Array of button rows, each represented by an Array of InlineKeyboardButton objects
    * @returns {InlineKeyboardButton[][]}
   */
   get inlineKeyboard() {
       return this._inlineKeyboard
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineKeyboardMarkup}
    */
   static deserialize(raw) {
      return new InlineKeyboardMarkup(raw[&#x27;inline_keyboard&#x27;] ? raw[&#x27;inline_keyboard&#x27;].map(arr =&#x3e; arr.map(item =&#x3e; InlineKeyboardButton
.deserialize(item))) : null)
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          inline_keyboard: this.inlineKeyboard ? this.inlineKeyboard.map(arr =&#x3e; arr.map(item =&#x3e; item.serialize())) : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQuery" id="apidoc.element.telegram-node-bot.Models.InlineQuery">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQuery
        <span class="apidocSignatureSpan">(id, from, location, query, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQuery {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} id
    * @param {User} from
    * @param {Location|null} [location]
    * @param {string} query
    * @param {string} offset
   */
</span>   constructor(id, from, location, query, offset) {
       this._id = id
       this._from = from
       this._location = location
       this._query = query
       this._offset = offset
   }

   /**
    * Unique identifier for this query
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * Sender
    * @returns {User}
   */
   get from() {
       return this._from
   }

   /**
    * Sender location, only for bots that request user location
    * @returns {Location|null}
   */
   get location() {
       return this._location
   }

   /**
    * Text of the query (up to 512 characters)
    * @returns {string}
   */
   get query() {
       return this._query
   }

   /**
    * Offset of the results to be returned, can be controlled by the bot
    * @returns {string}
   */
   get offset() {
       return this._offset
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQuery}
    */
   static deserialize(raw) {
      return new InlineQuery(
          raw[&#x27;id&#x27;],
          raw[&#x27;from&#x27;] ? User.deserialize(raw[&#x27;from&#x27;]) : null,
          raw[&#x27;location&#x27;] ? Location.deserialize(raw[&#x27;location&#x27;]) : null,
          raw[&#x27;query&#x27;],
          raw[&#x27;offset&#x27;]
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          id: this.id ? this.id : undefined,
          from: this.from ? this.from.serialize() : undefined,
          location: this.location ? this.location.serialize() : undefined,
          query: this.query ? this.query : undefined,
          offset: this.offset ? this.offset : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResult" id="apidoc.element.telegram-node-bot.Models.InlineQueryResult">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResult
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResult {
    toJSON() { }

    get id() { }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultArticle" id="apidoc.element.telegram-node-bot.Models.InlineQueryResultArticle">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultArticle
        <span class="apidocSignatureSpan">( type, id, title, inputMessageContent, replyMarkup, url, hideUrl, description, thumbUrl, thumbWidth, thumbHeight )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResultArticle extends InlineQueryResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {string} id
    * @param {string} title
    * @param {InputMessageContent} inputMessageContent
    * @param {InlineKeyboardMarkup|null} [replyMarkup]
    * @param {string|null} [url]
    * @param {boolean|null} [hideUrl]
    * @param {string|null} [description]
    * @param {string|null} [thumbUrl]
    * @param {number|null} [thumbWidth]
    * @param {number|null} [thumbHeight]
   */
</span>   constructor( type, id, title, inputMessageContent, replyMarkup, url, hideUrl, description, thumbUrl, thumbWidth, thumbHeight ) {
       super()
       this._type = type
       this._id = id
       this._title = title
       this._inputMessageContent = inputMessageContent
       this._replyMarkup = replyMarkup
       this._url = url
       this._hideUrl = hideUrl
       this._description = description
       this._thumbUrl = thumbUrl
       this._thumbWidth = thumbWidth
       this._thumbHeight = thumbHeight
   }

   /**
    * Type of the result, must be article
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Unique identifier for this result, 1-64 Bytes
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * Title of the result
    * @returns {string}
   */
   get title() {
       return this._title
   }

   /**
    * Content of the message to be sent
    * @returns {InputMessageContent}
   */
   get inputMessageContent() {
       return this._inputMessageContent
   }

   /**
    * Inline keyboard attached to the message
    * @returns {InlineKeyboardMarkup|null}
   */
   get replyMarkup() {
       return this._replyMarkup
   }

   /**
    * URL of the result
    * @returns {string|null}
   */
   get url() {
       return this._url
   }

   /**
    * Pass True, if you don&#x27;t want the URL to be shown in the message
    * @returns {boolean|null}
   */
   get hideUrl() {
       return this._hideUrl
   }

   /**
    * Short description of the result
    * @returns {string|null}
   */
   get description() {
       return this._description
   }

   /**
    * Url of the thumbnail for the result
    * @returns {string|null}
   */
   get thumbUrl() {
       return this._thumbUrl
   }

   /**
    * Thumbnail width
    * @returns {number|null}
   */
   get thumbWidth() {
       return this._thumbWidth
   }

   /**
    * Thumbnail height
    * @returns {number|null}
   */
   get thumbHeight() {
       return this._thumbHeight
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQueryResultArticle}
    */
   static deserialize(raw) {
      return new InlineQueryResultArticle(
          raw[&#x27;type&#x27;],
          raw[&#x27;id&#x27;],
          raw[&#x27;title&#x27;],
          raw[&#x27;input_message_content&#x27;] ? InputMessageContent.deserialize(raw[&#x27;input_message_content&#x27;]) : null,
          raw[&#x27;reply_markup&#x27;] ? InlineKeyboardMarkup.deserialize(raw[&#x27;reply_markup&#x27;]) : null,
          raw[&#x27;url&#x27;] ? raw[&#x27;url&#x27;] : null,
          raw[&#x27;hide_url&#x27;] ? raw[&#x27;hide_url&#x27;] : null,
          raw[&#x27;description&#x27;] ? raw[&#x27;description&#x27;] : null,
          raw[&#x27;thumb_url&#x27;] ? raw[&#x27;thumb_url&#x27;] : null,
          raw[&#x27;thumb_width&#x27;] ? raw[&#x27;thumb_width&#x27;] : null,
          raw[&#x27;thumb_height&#x27;] ? raw[&#x27;thumb_height&#x27;] : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undefined,
          id: this.id ? this.id : undefined,
          title: this.title ? this.title : undefined,
          input_message_content: this.inputMessageContent ? this.inputMessageContent.serialize() : undefined,
          reply_markup: this.replyMarkup ? this.replyMarkup.serialize() : undefined,
          url: this.url ? this.url : undefined,
          hide_url: this.hideUrl ? this.hideUrl : undefined,
          description: this.description ? this.description : undefined,
          thumb_url: this.thumbUrl ? this.thumbUrl : undefined,
          thumb_width: this.thumbWidth ? this ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultAudio" id="apidoc.element.telegram-node-bot.Models.InlineQueryResultAudio">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultAudio
        <span class="apidocSignatureSpan">( type, id, audioUrl, title, caption, performer, audioDuration, replyMarkup, inputMessageContent )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResultAudio extends InlineQueryResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {string} id
    * @param {string} audioUrl
    * @param {string} title
    * @param {string|null} [caption]
    * @param {string|null} [performer]
    * @param {number|null} [audioDuration]
    * @param {InlineKeyboardMarkup|null} [replyMarkup]
    * @param {InputMessageContent|null} [inputMessageContent]
   */
</span>   constructor( type, id, audioUrl, title, caption, performer, audioDuration, replyMarkup, inputMessageContent ) {
       super()
       this._type = type
       this._id = id
       this._audioUrl = audioUrl
       this._title = title
       this._caption = caption
       this._performer = performer
       this._audioDuration = audioDuration
       this._replyMarkup = replyMarkup
       this._inputMessageContent = inputMessageContent
   }

   /**
    * Type of the result, must be audio
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Unique identifier for this result, 1-64 bytes
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * A valid URL for the audio file
    * @returns {string}
   */
   get audioUrl() {
       return this._audioUrl
   }

   /**
    * Title
    * @returns {string}
   */
   get title() {
       return this._title
   }

   /**
    * Caption, 0-200 characters
    * @returns {string|null}
   */
   get caption() {
       return this._caption
   }

   /**
    * Performer
    * @returns {string|null}
   */
   get performer() {
       return this._performer
   }

   /**
    * Audio duration in seconds
    * @returns {number|null}
   */
   get audioDuration() {
       return this._audioDuration
   }

   /**
    * Inline keyboard attached to the message
    * @returns {InlineKeyboardMarkup|null}
   */
   get replyMarkup() {
       return this._replyMarkup
   }

   /**
    * Content of the message to be sent instead of the audio
    * @returns {InputMessageContent|null}
   */
   get inputMessageContent() {
       return this._inputMessageContent
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQueryResultAudio}
    */
   static deserialize(raw) {
      return new InlineQueryResultAudio(
          raw[&#x27;type&#x27;],
          raw[&#x27;id&#x27;],
          raw[&#x27;audio_url&#x27;],
          raw[&#x27;title&#x27;],
          raw[&#x27;caption&#x27;] ? raw[&#x27;caption&#x27;] : null,
          raw[&#x27;performer&#x27;] ? raw[&#x27;performer&#x27;] : null,
          raw[&#x27;audio_duration&#x27;] ? raw[&#x27;audio_duration&#x27;] : null,
          raw[&#x27;reply_markup&#x27;] ? InlineKeyboardMarkup.deserialize(raw[&#x27;reply_markup&#x27;]) : null,
          raw[&#x27;input_message_content&#x27;] ? InputMessageContent.deserialize(raw[&#x27;input_message_content&#x27;]) : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undefined,
          id: this.id ? this.id : undefined,
          audio_url: this.audioUrl ? this.audioUrl : undefined,
          title: this.title ? this.title : undefined,
          caption: this.caption ? this.caption : undefined,
          performer: this.performer ? this.performer : undefined,
          audio_duration: this.audioDuration ? this.audioDuration : undefined,
          reply_markup: this.replyMarkup ? this.replyMarkup.serialize() : undefined,
          input_message_content: this.inputMessageContent ? this.inputMessageContent.serialize() : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedAudio" id="apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedAudio">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultCachedAudio
        <span class="apidocSignatureSpan">(type, id, audioFileId, caption, replyMarkup, inputMessageContent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResultCachedAudio extends InlineQueryResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {string} id
    * @param {string} audioFileId
    * @param {string|null} [caption]
    * @param {InlineKeyboardMarkup|null} [replyMarkup]
    * @param {InputMessageContent|null} [inputMessageContent]
   */
</span>   constructor(type, id, audioFileId, caption, replyMarkup, inputMessageContent) {
       super()
       this._type = type
       this._id = id
       this._audioFileId = audioFileId
       this._caption = caption
       this._replyMarkup = replyMarkup
       this._inputMessageContent = inputMessageContent
   }

   /**
    * Type of the result, must be audio
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Unique identifier for this result, 1-64 bytes
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * A valid file identifier for the audio file
    * @returns {string}
   */
   get audioFileId() {
       return this._audioFileId
   }

   /**
    * Caption, 0-200 characters
    * @returns {string|null}
   */
   get caption() {
       return this._caption
   }

   /**
    * Inline keyboard attached to the message
    * @returns {InlineKeyboardMarkup|null}
   */
   get replyMarkup() {
       return this._replyMarkup
   }

   /**
    * Content of the message to be sent instead of the audio
    * @returns {InputMessageContent|null}
   */
   get inputMessageContent() {
       return this._inputMessageContent
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQueryResultCachedAudio}
    */
   static deserialize(raw) {
      return new InlineQueryResultCachedAudio(
          raw[&#x27;type&#x27;],
          raw[&#x27;id&#x27;],
          raw[&#x27;audio_file_id&#x27;],
          raw[&#x27;caption&#x27;] ? raw[&#x27;caption&#x27;] : null,
          raw[&#x27;reply_markup&#x27;] ? InlineKeyboardMarkup.deserialize(raw[&#x27;reply_markup&#x27;]) : null,
          raw[&#x27;input_message_content&#x27;] ? InputMessageContent.deserialize(raw[&#x27;input_message_content&#x27;]) : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undefined,
          id: this.id ? this.id : undefined,
          audio_file_id: this.audioFileId ? this.audioFileId : undefined,
          caption: this.caption ? this.caption : undefined,
          reply_markup: this.replyMarkup ? this.replyMarkup.serialize() : undefined,
          input_message_content: this.inputMessageContent ? this.inputMessageContent.serialize() : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedDocument" id="apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedDocument">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultCachedDocument
        <span class="apidocSignatureSpan">( type, id, title, documentFileId, description, caption, replyMarkup, inputMessageContent )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResultCachedDocument extends InlineQueryResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {string} id
    * @param {string} title
    * @param {string} documentFileId
    * @param {string|null} [description]
    * @param {string|null} [caption]
    * @param {InlineKeyboardMarkup|null} [replyMarkup]
    * @param {InputMessageContent|null} [inputMessageContent]
   */
</span>   constructor( type, id, title, documentFileId, description, caption, replyMarkup, inputMessageContent ) {
       super()
       this._type = type
       this._id = id
       this._title = title
       this._documentFileId = documentFileId
       this._description = description
       this._caption = caption
       this._replyMarkup = replyMarkup
       this._inputMessageContent = inputMessageContent
   }

   /**
    * Type of the result, must be document
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Unique identifier for this result, 1-64 bytes
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * Title for the result
    * @returns {string}
   */
   get title() {
       return this._title
   }

   /**
    * A valid file identifier for the file
    * @returns {string}
   */
   get documentFileId() {
       return this._documentFileId
   }

   /**
    * Short description of the result
    * @returns {string|null}
   */
   get description() {
       return this._description
   }

   /**
    * Caption of the document to be sent, 0-200 characters
    * @returns {string|null}
   */
   get caption() {
       return this._caption
   }

   /**
    * Inline keyboard attached to the message
    * @returns {InlineKeyboardMarkup|null}
   */
   get replyMarkup() {
       return this._replyMarkup
   }

   /**
    * Content of the message to be sent instead of the file
    * @returns {InputMessageContent|null}
   */
   get inputMessageContent() {
       return this._inputMessageContent
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQueryResultCachedDocument}
    */
   static deserialize(raw) {
      return new InlineQueryResultCachedDocument(
          raw[&#x27;type&#x27;],
          raw[&#x27;id&#x27;],
          raw[&#x27;title&#x27;],
          raw[&#x27;document_file_id&#x27;],
          raw[&#x27;description&#x27;] ? raw[&#x27;description&#x27;] : null,
          raw[&#x27;caption&#x27;] ? raw[&#x27;caption&#x27;] : null,
          raw[&#x27;reply_markup&#x27;] ? InlineKeyboardMarkup.deserialize(raw[&#x27;reply_markup&#x27;]) : null,
          raw[&#x27;input_message_content&#x27;] ? InputMessageContent.deserialize(raw[&#x27;input_message_content&#x27;]) : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undefined,
          id: this.id ? this.id : undefined,
          title: this.title ? this.title : undefined,
          document_file_id: this.documentFileId ? this.documentFileId : undefined,
          description: this.description ? this.description : undefined,
          caption: this.caption ? this.caption : undefined,
          reply_markup: this.replyMarkup ? this.replyMarkup.serialize() : undefined,
          input_message_content: this.inputMessageContent ? this.inputMessageContent.serialize() : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedGif" id="apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedGif">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultCachedGif
        <span class="apidocSignatureSpan">( type, id, gifFileId, title, caption, replyMarkup, inputMessageContent )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResultCachedGif extends InlineQueryResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {string} id
    * @param {string} gifFileId
    * @param {string|null} [title]
    * @param {string|null} [caption]
    * @param {InlineKeyboardMarkup|null} [replyMarkup]
    * @param {InputMessageContent|null} [inputMessageContent]
   */
</span>   constructor( type, id, gifFileId, title, caption, replyMarkup, inputMessageContent ) {
       super()
       this._type = type
       this._id = id
       this._gifFileId = gifFileId
       this._title = title
       this._caption = caption
       this._replyMarkup = replyMarkup
       this._inputMessageContent = inputMessageContent
   }

   /**
    * Type of the result, must be gif
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Unique identifier for this result, 1-64 bytes
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * A valid file identifier for the GIF file
    * @returns {string}
   */
   get gifFileId() {
       return this._gifFileId
   }

   /**
    * Title for the result
    * @returns {string|null}
   */
   get title() {
       return this._title
   }

   /**
    * Caption of the GIF file to be sent, 0-200 characters
    * @returns {string|null}
   */
   get caption() {
       return this._caption
   }

   /**
    * Inline keyboard attached to the message
    * @returns {InlineKeyboardMarkup|null}
   */
   get replyMarkup() {
       return this._replyMarkup
   }

   /**
    * Content of the message to be sent instead of the GIF animation
    * @returns {InputMessageContent|null}
   */
   get inputMessageContent() {
       return this._inputMessageContent
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQueryResultCachedGif}
    */
   static deserialize(raw) {
      return new InlineQueryResultCachedGif(
          raw[&#x27;type&#x27;],
          raw[&#x27;id&#x27;],
          raw[&#x27;gif_file_id&#x27;],
          raw[&#x27;title&#x27;] ? raw[&#x27;title&#x27;] : null,
          raw[&#x27;caption&#x27;] ? raw[&#x27;caption&#x27;] : null,
          raw[&#x27;reply_markup&#x27;] ? InlineKeyboardMarkup.deserialize(raw[&#x27;reply_markup&#x27;]) : null,
          raw[&#x27;input_message_content&#x27;] ? InputMessageContent.deserialize(raw[&#x27;input_message_content&#x27;]) : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undefined,
          id: this.id ? this.id : undefined,
          gif_file_id: this.gifFileId ? this.gifFileId : undefined,
          title: this.title ? this.title : undefined,
          caption: this.caption ? this.caption : undefined,
          reply_markup: this.replyMarkup ? this.replyMarkup.serialize() : undefined,
          input_message_content: this.inputMessageContent ? this.inputMessageContent.serialize() : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedMpeg4Gif" id="apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedMpeg4Gif">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultCachedMpeg4Gif
        <span class="apidocSignatureSpan">( type, id, mpeg4FileId, title, caption, replyMarkup, inputMessageContent )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResultCachedMpeg4Gif extends InlineQueryResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {string} id
    * @param {string} mpeg4FileId
    * @param {string|null} [title]
    * @param {string|null} [caption]
    * @param {InlineKeyboardMarkup|null} [replyMarkup]
    * @param {InputMessageContent|null} [inputMessageContent]
   */
</span>   constructor( type, id, mpeg4FileId, title, caption, replyMarkup, inputMessageContent ) {
       super()
       this._type = type
       this._id = id
       this._mpeg4FileId = mpeg4FileId
       this._title = title
       this._caption = caption
       this._replyMarkup = replyMarkup
       this._inputMessageContent = inputMessageContent
   }

   /**
    * Type of the result, must be mpeg4_gif
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Unique identifier for this result, 1-64 bytes
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * A valid file identifier for the MP4 file
    * @returns {string}
   */
   get mpeg4FileId() {
       return this._mpeg4FileId
   }

   /**
    * Title for the result
    * @returns {string|null}
   */
   get title() {
       return this._title
   }

   /**
    * Caption of the MPEG-4 file to be sent, 0-200 characters
    * @returns {string|null}
   */
   get caption() {
       return this._caption
   }

   /**
    * Inline keyboard attached to the message
    * @returns {InlineKeyboardMarkup|null}
   */
   get replyMarkup() {
       return this._replyMarkup
   }

   /**
    * Content of the message to be sent instead of the video animation
    * @returns {InputMessageContent|null}
   */
   get inputMessageContent() {
       return this._inputMessageContent
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQueryResultCachedMpeg4Gif}
    */
   static deserialize(raw) {
      return new InlineQueryResultCachedMpeg4Gif(
          raw[&#x27;type&#x27;],
          raw[&#x27;id&#x27;],
          raw[&#x27;mpeg4_file_id&#x27;],
          raw[&#x27;title&#x27;] ? raw[&#x27;title&#x27;] : null,
          raw[&#x27;caption&#x27;] ? raw[&#x27;caption&#x27;] : null,
          raw[&#x27;reply_markup&#x27;] ? InlineKeyboardMarkup.deserialize(raw[&#x27;reply_markup&#x27;]) : null,
          raw[&#x27;input_message_content&#x27;] ? InputMessageContent.deserialize(raw[&#x27;input_message_content&#x27;]) : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undefined,
          id: this.id ? this.id : undefined,
          mpeg4_file_id: this.mpeg4FileId ? this.mpeg4FileId : undefined,
          title: this.title ? this.title : undefined,
          caption: this.caption ? this.caption : undefined,
          reply_markup: this.replyMarkup ? this.replyMarkup.serialize() : undefined,
          input_message_content: this.inputMessageContent ? this.inputMessageContent.serialize() : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedPhoto" id="apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedPhoto">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultCachedPhoto
        <span class="apidocSignatureSpan">( type, id, photoFileId, title, description, caption, replyMarkup, inputMessageContent )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResultCachedPhoto extends InlineQueryResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {string} id
    * @param {string} photoFileId
    * @param {string|null} [title]
    * @param {string|null} [description]
    * @param {string|null} [caption]
    * @param {InlineKeyboardMarkup|null} [replyMarkup]
    * @param {InputMessageContent|null} [inputMessageContent]
   */
</span>   constructor( type, id, photoFileId, title, description, caption, replyMarkup, inputMessageContent ) {
       super()
       this._type = type
       this._id = id
       this._photoFileId = photoFileId
       this._title = title
       this._description = description
       this._caption = caption
       this._replyMarkup = replyMarkup
       this._inputMessageContent = inputMessageContent
   }

   /**
    * Type of the result, must be photo
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Unique identifier for this result, 1-64 bytes
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * A valid file identifier of the photo
    * @returns {string}
   */
   get photoFileId() {
       return this._photoFileId
   }

   /**
    * Title for the result
    * @returns {string|null}
   */
   get title() {
       return this._title
   }

   /**
    * Short description of the result
    * @returns {string|null}
   */
   get description() {
       return this._description
   }

   /**
    * Caption of the photo to be sent, 0-200 characters
    * @returns {string|null}
   */
   get caption() {
       return this._caption
   }

   /**
    * Inline keyboard attached to the message
    * @returns {InlineKeyboardMarkup|null}
   */
   get replyMarkup() {
       return this._replyMarkup
   }

   /**
    * Content of the message to be sent instead of the photo
    * @returns {InputMessageContent|null}
   */
   get inputMessageContent() {
       return this._inputMessageContent
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQueryResultCachedPhoto}
    */
   static deserialize(raw) {
      return new InlineQueryResultCachedPhoto(
          raw[&#x27;type&#x27;],
          raw[&#x27;id&#x27;],
          raw[&#x27;photo_file_id&#x27;],
          raw[&#x27;title&#x27;] ? raw[&#x27;title&#x27;] : null,
          raw[&#x27;description&#x27;] ? raw[&#x27;description&#x27;] : null,
          raw[&#x27;caption&#x27;] ? raw[&#x27;caption&#x27;] : null,
          raw[&#x27;reply_markup&#x27;] ? InlineKeyboardMarkup.deserialize(raw[&#x27;reply_markup&#x27;]) : null,
          raw[&#x27;input_message_content&#x27;] ? InputMessageContent.deserialize(raw[&#x27;input_message_content&#x27;]) : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undefined,
          id: this.id ? this.id : undefined,
          photo_file_id: this.photoFileId ? this.photoFileId : undefined,
          title: this.title ? this.title : undefined,
          description: this.description ? this.description : undefined,
          caption: this.caption ? this.caption : undefined,
          reply_markup: this.replyMarkup ? this.replyMarkup.serialize() : undefined,
          input_message_content: this.inputMessageContent ? this.inputMessageContent.serialize() : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedSticker" id="apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedSticker">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultCachedSticker
        <span class="apidocSignatureSpan">(type, id, stickerFileId, replyMarkup, inputMessageContent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResultCachedSticker extends InlineQueryResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {string} id
    * @param {string} stickerFileId
    * @param {InlineKeyboardMarkup|null} [replyMarkup]
    * @param {InputMessageContent|null} [inputMessageContent]
   */
</span>   constructor(type, id, stickerFileId, replyMarkup, inputMessageContent) {
       super()
       this._type = type
       this._id = id
       this._stickerFileId = stickerFileId
       this._replyMarkup = replyMarkup
       this._inputMessageContent = inputMessageContent
   }

   /**
    * Type of the result, must be sticker
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Unique identifier for this result, 1-64 bytes
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * A valid file identifier of the sticker
    * @returns {string}
   */
   get stickerFileId() {
       return this._stickerFileId
   }

   /**
    * Inline keyboard attached to the message
    * @returns {InlineKeyboardMarkup|null}
   */
   get replyMarkup() {
       return this._replyMarkup
   }

   /**
    * Content of the message to be sent instead of the sticker
    * @returns {InputMessageContent|null}
   */
   get inputMessageContent() {
       return this._inputMessageContent
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQueryResultCachedSticker}
    */
   static deserialize(raw) {
      return new InlineQueryResultCachedSticker(
          raw[&#x27;type&#x27;],
          raw[&#x27;id&#x27;],
          raw[&#x27;sticker_file_id&#x27;],
          raw[&#x27;reply_markup&#x27;] ? InlineKeyboardMarkup.deserialize(raw[&#x27;reply_markup&#x27;]) : null,
          raw[&#x27;input_message_content&#x27;] ? InputMessageContent.deserialize(raw[&#x27;input_message_content&#x27;]) : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undefined,
          id: this.id ? this.id : undefined,
          sticker_file_id: this.stickerFileId ? this.stickerFileId : undefined,
          reply_markup: this.replyMarkup ? this.replyMarkup.serialize() : undefined,
          input_message_content: this.inputMessageContent ? this.inputMessageContent.serialize() : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedVideo" id="apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedVideo">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultCachedVideo
        <span class="apidocSignatureSpan">( type, id, videoFileId, title, description, caption, replyMarkup, inputMessageContent )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResultCachedVideo extends InlineQueryResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {string} id
    * @param {string} videoFileId
    * @param {string} title
    * @param {string|null} [description]
    * @param {string|null} [caption]
    * @param {InlineKeyboardMarkup|null} [replyMarkup]
    * @param {InputMessageContent|null} [inputMessageContent]
   */
</span>   constructor( type, id, videoFileId, title, description, caption, replyMarkup, inputMessageContent ) {
       super()
       this._type = type
       this._id = id
       this._videoFileId = videoFileId
       this._title = title
       this._description = description
       this._caption = caption
       this._replyMarkup = replyMarkup
       this._inputMessageContent = inputMessageContent
   }

   /**
    * Type of the result, must be video
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Unique identifier for this result, 1-64 bytes
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * A valid file identifier for the video file
    * @returns {string}
   */
   get videoFileId() {
       return this._videoFileId
   }

   /**
    * Title for the result
    * @returns {string}
   */
   get title() {
       return this._title
   }

   /**
    * Short description of the result
    * @returns {string|null}
   */
   get description() {
       return this._description
   }

   /**
    * Caption of the video to be sent, 0-200 characters
    * @returns {string|null}
   */
   get caption() {
       return this._caption
   }

   /**
    * Inline keyboard attached to the message
    * @returns {InlineKeyboardMarkup|null}
   */
   get replyMarkup() {
       return this._replyMarkup
   }

   /**
    * Content of the message to be sent instead of the video
    * @returns {InputMessageContent|null}
   */
   get inputMessageContent() {
       return this._inputMessageContent
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQueryResultCachedVideo}
    */
   static deserialize(raw) {
      return new InlineQueryResultCachedVideo(
          raw[&#x27;type&#x27;],
          raw[&#x27;id&#x27;],
          raw[&#x27;video_file_id&#x27;],
          raw[&#x27;title&#x27;],
          raw[&#x27;description&#x27;] ? raw[&#x27;description&#x27;] : null,
          raw[&#x27;caption&#x27;] ? raw[&#x27;caption&#x27;] : null,
          raw[&#x27;reply_markup&#x27;] ? InlineKeyboardMarkup.deserialize(raw[&#x27;reply_markup&#x27;]) : null,
          raw[&#x27;input_message_content&#x27;] ? InputMessageContent.deserialize(raw[&#x27;input_message_content&#x27;]) : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undefined,
          id: this.id ? this.id : undefined,
          video_file_id: this.videoFileId ? this.videoFileId : undefined,
          title: this.title ? this.title : undefined,
          description: this.description ? this.description : undefined,
          caption: this.caption ? this.caption : undefined,
          reply_markup: this.replyMarkup ? this.replyMarkup.serialize() : undefined,
          input_message_content: this.inputMessageContent ? this.inputMessageContent.serialize() : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedVoice" id="apidoc.element.telegram-node-bot.Models.InlineQueryResultCachedVoice">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultCachedVoice
        <span class="apidocSignatureSpan">( type, id, voiceFileId, title, caption, replyMarkup, inputMessageContent )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResultCachedVoice extends InlineQueryResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {string} id
    * @param {string} voiceFileId
    * @param {string} title
    * @param {string|null} [caption]
    * @param {InlineKeyboardMarkup|null} [replyMarkup]
    * @param {InputMessageContent|null} [inputMessageContent]
   */
</span>   constructor( type, id, voiceFileId, title, caption, replyMarkup, inputMessageContent ) {
       super()
       this._type = type
       this._id = id
       this._voiceFileId = voiceFileId
       this._title = title
       this._caption = caption
       this._replyMarkup = replyMarkup
       this._inputMessageContent = inputMessageContent
   }

   /**
    * Type of the result, must be voice
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Unique identifier for this result, 1-64 bytes
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * A valid file identifier for the voice message
    * @returns {string}
   */
   get voiceFileId() {
       return this._voiceFileId
   }

   /**
    * Voice message title
    * @returns {string}
   */
   get title() {
       return this._title
   }

   /**
    * Caption, 0-200 characters
    * @returns {string|null}
   */
   get caption() {
       return this._caption
   }

   /**
    * Inline keyboard attached to the message
    * @returns {InlineKeyboardMarkup|null}
   */
   get replyMarkup() {
       return this._replyMarkup
   }

   /**
    * Content of the message to be sent instead of the voice message
    * @returns {InputMessageContent|null}
   */
   get inputMessageContent() {
       return this._inputMessageContent
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQueryResultCachedVoice}
    */
   static deserialize(raw) {
      return new InlineQueryResultCachedVoice(
          raw[&#x27;type&#x27;],
          raw[&#x27;id&#x27;],
          raw[&#x27;voice_file_id&#x27;],
          raw[&#x27;title&#x27;],
          raw[&#x27;caption&#x27;] ? raw[&#x27;caption&#x27;] : null,
          raw[&#x27;reply_markup&#x27;] ? InlineKeyboardMarkup.deserialize(raw[&#x27;reply_markup&#x27;]) : null,
          raw[&#x27;input_message_content&#x27;] ? InputMessageContent.deserialize(raw[&#x27;input_message_content&#x27;]) : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undefined,
          id: this.id ? this.id : undefined,
          voice_file_id: this.voiceFileId ? this.voiceFileId : undefined,
          title: this.title ? this.title : undefined,
          caption: this.caption ? this.caption : undefined,
          reply_markup: this.replyMarkup ? this.replyMarkup.serialize() : undefined,
          input_message_content: this.inputMessageContent ? this.inputMessageContent.serialize() : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultContact" id="apidoc.element.telegram-node-bot.Models.InlineQueryResultContact">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultContact
        <span class="apidocSignatureSpan">( type, id, phoneNumber, firstName, lastName, replyMarkup, inputMessageContent, thumbUrl, thumbWidth, thumbHeight )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResultContact extends InlineQueryResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {string} id
    * @param {string} phoneNumber
    * @param {string} firstName
    * @param {string|null} [lastName]
    * @param {InlineKeyboardMarkup|null} [replyMarkup]
    * @param {InputMessageContent|null} [inputMessageContent]
    * @param {string|null} [thumbUrl]
    * @param {number|null} [thumbWidth]
    * @param {number|null} [thumbHeight]
   */
</span>   constructor( type, id, phoneNumber, firstName, lastName, replyMarkup, inputMessageContent, thumbUrl, thumbWidth, thumbHeight ) {
       super()
       this._type = type
       this._id = id
       this._phoneNumber = phoneNumber
       this._firstName = firstName
       this._lastName = lastName
       this._replyMarkup = replyMarkup
       this._inputMessageContent = inputMessageContent
       this._thumbUrl = thumbUrl
       this._thumbWidth = thumbWidth
       this._thumbHeight = thumbHeight
   }

   /**
    * Type of the result, must be contact
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Unique identifier for this result, 1-64 Bytes
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * Contact&#x27;s phone number
    * @returns {string}
   */
   get phoneNumber() {
       return this._phoneNumber
   }

   /**
    * Contact&#x27;s first name
    * @returns {string}
   */
   get firstName() {
       return this._firstName
   }

   /**
    * Contact&#x27;s last name
    * @returns {string|null}
   */
   get lastName() {
       return this._lastName
   }

   /**
    * Inline keyboard attached to the message
    * @returns {InlineKeyboardMarkup|null}
   */
   get replyMarkup() {
       return this._replyMarkup
   }

   /**
    * Content of the message to be sent instead of the contact
    * @returns {InputMessageContent|null}
   */
   get inputMessageContent() {
       return this._inputMessageContent
   }

   /**
    * Url of the thumbnail for the result
    * @returns {string|null}
   */
   get thumbUrl() {
       return this._thumbUrl
   }

   /**
    * Thumbnail width
    * @returns {number|null}
   */
   get thumbWidth() {
       return this._thumbWidth
   }

   /**
    * Thumbnail height
    * @returns {number|null}
   */
   get thumbHeight() {
       return this._thumbHeight
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQueryResultContact}
    */
   static deserialize(raw) {
      return new InlineQueryResultContact(
          raw[&#x27;type&#x27;],
          raw[&#x27;id&#x27;],
          raw[&#x27;phone_number&#x27;],
          raw[&#x27;first_name&#x27;],
          raw[&#x27;last_name&#x27;] ? raw[&#x27;last_name&#x27;] : null,
          raw[&#x27;reply_markup&#x27;] ? InlineKeyboardMarkup.deserialize(raw[&#x27;reply_markup&#x27;]) : null,
          raw[&#x27;input_message_content&#x27;] ? InputMessageContent.deserialize(raw[&#x27;input_message_content&#x27;]) : null,
          raw[&#x27;thumb_url&#x27;] ? raw[&#x27;thumb_url&#x27;] : null,
          raw[&#x27;thumb_width&#x27;] ? raw[&#x27;thumb_width&#x27;] : null,
          raw[&#x27;thumb_height&#x27;] ? raw[&#x27;thumb_height&#x27;] : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undefined,
          id: this.id ? this.id : undefined,
          phone_number: this.phoneNumber ? this.phoneNumber : undefined,
          first_name: this.firstName ? this.firstName : undefined,
          last_name: this.lastName ? this.lastName : undefined,
          reply_markup: this.replyMarkup ? this.replyMarkup.serialize() : undefined,
          input_message_content: this.inputMessageContent ? this.inputMessageContent.serialize() : undefined,
          thumb_url: this.thumbUrl ? this.thumbUrl : undefined,
          thumb_width: this.thumbWidth ? this.thumbWidth : undefined,
          thumb_height: this.thumbHeight ? this.thumbHeight : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultDocument" id="apidoc.element.telegram-node-bot.Models.InlineQueryResultDocument">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultDocument
        <span class="apidocSignatureSpan">( type, id, title, caption, documentUrl, mimeType, description, replyMarkup, inputMessageContent, thumbUrl, thumbWidth, thumbHeight )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResultDocument extends InlineQueryResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {string} id
    * @param {string} title
    * @param {string|null} [caption]
    * @param {string} documentUrl
    * @param {string} mimeType
    * @param {string|null} [description]
    * @param {InlineKeyboardMarkup|null} [replyMarkup]
    * @param {InputMessageContent|null} [inputMessageContent]
    * @param {string|null} [thumbUrl]
    * @param {number|null} [thumbWidth]
    * @param {number|null} [thumbHeight]
   */
</span>   constructor( type, id, title, caption, documentUrl, mimeType, description, replyMarkup, inputMessageContent, thumbUrl, thumbWidth, thumbHeight ) {
       super()
       this._type = type
       this._id = id
       this._title = title
       this._caption = caption
       this._documentUrl = documentUrl
       this._mimeType = mimeType
       this._description = description
       this._replyMarkup = replyMarkup
       this._inputMessageContent = inputMessageContent
       this._thumbUrl = thumbUrl
       this._thumbWidth = thumbWidth
       this._thumbHeight = thumbHeight
   }

   /**
    * Type of the result, must be document
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Unique identifier for this result, 1-64 bytes
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * Title for the result
    * @returns {string}
   */
   get title() {
       return this._title
   }

   /**
    * Caption of the document to be sent, 0-200 characters
    * @returns {string|null}
   */
   get caption() {
       return this._caption
   }

   /**
    * A valid URL for the file
    * @returns {string}
   */
   get documentUrl() {
       return this._documentUrl
   }

   /**
    * Mime type of the content of the file, either application/pdf or application/zip
    * @returns {string}
   */
   get mimeType() {
       return this._mimeType
   }

   /**
    * Short description of the result
    * @returns {string|null}
   */
   get description() {
       return this._description
   }

   /**
    * Inline keyboard attached to the message
    * @returns {InlineKeyboardMarkup|null}
   */
   get replyMarkup() {
       return this._replyMarkup
   }

   /**
    * Content of the message to be sent instead of the file
    * @returns {InputMessageContent|null}
   */
   get inputMessageContent() {
       return this._inputMessageContent
   }

   /**
    * URL of the thumbnail (jpeg only) for the file
    * @returns {string|null}
   */
   get thumbUrl() {
       return this._thumbUrl
   }

   /**
    * Thumbnail width
    * @returns {number|null}
   */
   get thumbWidth() {
       return this._thumbWidth
   }

   /**
    * Thumbnail height
    * @returns {number|null}
   */
   get thumbHeight() {
       return this._thumbHeight
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQueryResultDocument}
    */
   static deserialize(raw) {
      return new InlineQueryResultDocument(
          raw[&#x27;type&#x27;],
          raw[&#x27;id&#x27;],
          raw[&#x27;title&#x27;],
          raw[&#x27;caption&#x27;] ? raw[&#x27;caption&#x27;] : null,
          raw[&#x27;document_url&#x27;],
          raw[&#x27;mime_type&#x27;],
          raw[&#x27;description&#x27;] ? raw[&#x27;description&#x27;] : null,
          raw[&#x27;reply_markup&#x27;] ? InlineKeyboardMarkup.deserialize(raw[&#x27;reply_markup&#x27;]) : null,
          raw[&#x27;input_message_content&#x27;] ? InputMessageContent.deserialize(raw[&#x27;input_message_content&#x27;]) : null,
          raw[&#x27;thumb_url&#x27;] ? raw[&#x27;thumb_url&#x27;] : null,
          raw[&#x27;thumb_width&#x27;] ? raw[&#x27;thumb_width&#x27;] : null,
          raw[&#x27;thumb_height&#x27;] ? raw[&#x27;thumb_height&#x27;] : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undefined,
          id: this.id ? this.id : undefined,
          title: this.title ? this.title : undefined,
          caption: this.caption ? this.caption : undefined,
          document_url: this.documentUrl ? this.documentUrl : undefined, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultGame" id="apidoc.element.telegram-node-bot.Models.InlineQueryResultGame">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultGame
        <span class="apidocSignatureSpan">(type, id, gameShortName, replyMarkup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResultGame extends InlineQueryResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {string} id
    * @param {string} gameShortName
    * @param {InlineKeyboardMarkup|null} [replyMarkup]
   */
</span>   constructor(type, id, gameShortName, replyMarkup) {
       super()
       this._type = type
       this._id = id
       this._gameShortName = gameShortName
       this._replyMarkup = replyMarkup
   }

   /**
    * Type of the result, must be game
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Unique identifier for this result, 1-64 bytes
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * Short name of the game
    * @returns {string}
   */
   get gameShortName() {
       return this._gameShortName
   }

   /**
    * Inline keyboard attached to the message
    * @returns {InlineKeyboardMarkup|null}
   */
   get replyMarkup() {
       return this._replyMarkup
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQueryResultGame}
    */
   static deserialize(raw) {
      return new InlineQueryResultGame(raw[&#x27;type&#x27;], raw[&#x27;id&#x27;], raw[&#x27;game_short_name&#x27;], raw[&#x27;reply_markup&#x27;] ? InlineKeyboardMarkup
.deserialize(raw[&#x27;reply_markup&#x27;]) : null)
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undefined,
          id: this.id ? this.id : undefined,
          game_short_name: this.gameShortName ? this.gameShortName : undefined,
          reply_markup: this.replyMarkup ? this.replyMarkup.serialize() : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultGif" id="apidoc.element.telegram-node-bot.Models.InlineQueryResultGif">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultGif
        <span class="apidocSignatureSpan">( type, id, gifUrl, gifWidth, gifHeight, thumbUrl, title, caption, replyMarkup, inputMessageContent )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResultGif extends InlineQueryResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {string} id
    * @param {string} gifUrl
    * @param {number|null} [gifWidth]
    * @param {number|null} [gifHeight]
    * @param {string} thumbUrl
    * @param {string|null} [title]
    * @param {string|null} [caption]
    * @param {InlineKeyboardMarkup|null} [replyMarkup]
    * @param {InputMessageContent|null} [inputMessageContent]
   */
</span>   constructor( type, id, gifUrl, gifWidth, gifHeight, thumbUrl, title, caption, replyMarkup, inputMessageContent ) {
       super()
       this._type = type
       this._id = id
       this._gifUrl = gifUrl
       this._gifWidth = gifWidth
       this._gifHeight = gifHeight
       this._thumbUrl = thumbUrl
       this._title = title
       this._caption = caption
       this._replyMarkup = replyMarkup
       this._inputMessageContent = inputMessageContent
   }

   /**
    * Type of the result, must be gif
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Unique identifier for this result, 1-64 bytes
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * A valid URL for the GIF file. File size must not exceed 1MB
    * @returns {string}
   */
   get gifUrl() {
       return this._gifUrl
   }

   /**
    * Width of the GIF
    * @returns {number|null}
   */
   get gifWidth() {
       return this._gifWidth
   }

   /**
    * Height of the GIF
    * @returns {number|null}
   */
   get gifHeight() {
       return this._gifHeight
   }

   /**
    * URL of the static thumbnail for the result (jpeg or gif)
    * @returns {string}
   */
   get thumbUrl() {
       return this._thumbUrl
   }

   /**
    * Title for the result
    * @returns {string|null}
   */
   get title() {
       return this._title
   }

   /**
    * Caption of the GIF file to be sent, 0-200 characters
    * @returns {string|null}
   */
   get caption() {
       return this._caption
   }

   /**
    * Inline keyboard attached to the message
    * @returns {InlineKeyboardMarkup|null}
   */
   get replyMarkup() {
       return this._replyMarkup
   }

   /**
    * Content of the message to be sent instead of the GIF animation
    * @returns {InputMessageContent|null}
   */
   get inputMessageContent() {
       return this._inputMessageContent
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQueryResultGif}
    */
   static deserialize(raw) {
      return new InlineQueryResultGif(
          raw[&#x27;type&#x27;],
          raw[&#x27;id&#x27;],
          raw[&#x27;gif_url&#x27;],
          raw[&#x27;gif_width&#x27;] ? raw[&#x27;gif_width&#x27;] : null,
          raw[&#x27;gif_height&#x27;] ? raw[&#x27;gif_height&#x27;] : null,
          raw[&#x27;thumb_url&#x27;],
          raw[&#x27;title&#x27;] ? raw[&#x27;title&#x27;] : null,
          raw[&#x27;caption&#x27;] ? raw[&#x27;caption&#x27;] : null,
          raw[&#x27;reply_markup&#x27;] ? InlineKeyboardMarkup.deserialize(raw[&#x27;reply_markup&#x27;]) : null,
          raw[&#x27;input_message_content&#x27;] ? InputMessageContent.deserialize(raw[&#x27;input_message_content&#x27;]) : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undefined,
          id: this.id ? this.id : undefined,
          gif_url: this.gifUrl ? this.gifUrl : undefined,
          gif_width: this.gifWidth ? this.gifWidth : undefined,
          gif_height: this.gifHeight ? this.gifHeight : undefined,
          thumb_url: this.thumbUrl ? this.thumbUrl : undefined,
          title: this.title ? this.title : undefined,
          caption: this.caption ? this.caption : undefined,
          reply_markup: this.replyMarkup ? this.replyMarkup.serialize() : undefined,
          input_message_content: this.inputMessageContent ? this.inputMessageContent.serialize() : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultLocation" id="apidoc.element.telegram-node-bot.Models.InlineQueryResultLocation">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultLocation
        <span class="apidocSignatureSpan">( type, id, latitude, longitude, title, replyMarkup, inputMessageContent, thumbUrl, thumbWidth, thumbHeight )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResultLocation extends InlineQueryResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {string} id
    * @param {number} latitude
    * @param {number} longitude
    * @param {string} title
    * @param {InlineKeyboardMarkup|null} [replyMarkup]
    * @param {InputMessageContent|null} [inputMessageContent]
    * @param {string|null} [thumbUrl]
    * @param {number|null} [thumbWidth]
    * @param {number|null} [thumbHeight]
   */
</span>   constructor( type, id, latitude, longitude, title, replyMarkup, inputMessageContent, thumbUrl, thumbWidth, thumbHeight ) {
       super()
       this._type = type
       this._id = id
       this._latitude = latitude
       this._longitude = longitude
       this._title = title
       this._replyMarkup = replyMarkup
       this._inputMessageContent = inputMessageContent
       this._thumbUrl = thumbUrl
       this._thumbWidth = thumbWidth
       this._thumbHeight = thumbHeight
   }

   /**
    * Type of the result, must be location
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Unique identifier for this result, 1-64 Bytes
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * Location latitude in degrees
    * @returns {number}
   */
   get latitude() {
       return this._latitude
   }

   /**
    * Location longitude in degrees
    * @returns {number}
   */
   get longitude() {
       return this._longitude
   }

   /**
    * Location title
    * @returns {string}
   */
   get title() {
       return this._title
   }

   /**
    * Inline keyboard attached to the message
    * @returns {InlineKeyboardMarkup|null}
   */
   get replyMarkup() {
       return this._replyMarkup
   }

   /**
    * Content of the message to be sent instead of the location
    * @returns {InputMessageContent|null}
   */
   get inputMessageContent() {
       return this._inputMessageContent
   }

   /**
    * Url of the thumbnail for the result
    * @returns {string|null}
   */
   get thumbUrl() {
       return this._thumbUrl
   }

   /**
    * Thumbnail width
    * @returns {number|null}
   */
   get thumbWidth() {
       return this._thumbWidth
   }

   /**
    * Thumbnail height
    * @returns {number|null}
   */
   get thumbHeight() {
       return this._thumbHeight
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQueryResultLocation}
    */
   static deserialize(raw) {
      return new InlineQueryResultLocation(
          raw[&#x27;type&#x27;],
          raw[&#x27;id&#x27;],
          raw[&#x27;latitude&#x27;],
          raw[&#x27;longitude&#x27;],
          raw[&#x27;title&#x27;],
          raw[&#x27;reply_markup&#x27;] ? InlineKeyboardMarkup.deserialize(raw[&#x27;reply_markup&#x27;]) : null,
          raw[&#x27;input_message_content&#x27;] ? InputMessageContent.deserialize(raw[&#x27;input_message_content&#x27;]) : null,
          raw[&#x27;thumb_url&#x27;] ? raw[&#x27;thumb_url&#x27;] : null,
          raw[&#x27;thumb_width&#x27;] ? raw[&#x27;thumb_width&#x27;] : null,
          raw[&#x27;thumb_height&#x27;] ? raw[&#x27;thumb_height&#x27;] : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undefined,
          id: this.id ? this.id : undefined,
          latitude: this.latitude ? this.latitude : undefined,
          longitude: this.longitude ? this.longitude : undefined,
          title: this.title ? this.title : undefined,
          reply_markup: this.replyMarkup ? this.replyMarkup.serialize() : undefined,
          input_message_content: this.inputMessageContent ? this.inputMessageContent.serialize() : undefined,
          thumb_url: this.thumbUrl ? this.thumbUrl : undefined,
          thumb_width: this.thumbWidth ? this.thumbWidth : undefined,
          thumb_height: this.thumbHeight ? this.thumbHeight : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultMpeg4Gif" id="apidoc.element.telegram-node-bot.Models.InlineQueryResultMpeg4Gif">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultMpeg4Gif
        <span class="apidocSignatureSpan">( type, id, mpeg4Url, mpeg4Width, mpeg4Height, thumbUrl, title, caption, replyMarkup, inputMessageContent )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResultMpeg4Gif extends InlineQueryResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {string} id
    * @param {string} mpeg4Url
    * @param {number|null} [mpeg4Width]
    * @param {number|null} [mpeg4Height]
    * @param {string} thumbUrl
    * @param {string|null} [title]
    * @param {string|null} [caption]
    * @param {InlineKeyboardMarkup|null} [replyMarkup]
    * @param {InputMessageContent|null} [inputMessageContent]
   */
</span>   constructor( type, id, mpeg4Url, mpeg4Width, mpeg4Height, thumbUrl, title, caption, replyMarkup, inputMessageContent ) {
       super()
       this._type = type
       this._id = id
       this._mpeg4Url = mpeg4Url
       this._mpeg4Width = mpeg4Width
       this._mpeg4Height = mpeg4Height
       this._thumbUrl = thumbUrl
       this._title = title
       this._caption = caption
       this._replyMarkup = replyMarkup
       this._inputMessageContent = inputMessageContent
   }

   /**
    * Type of the result, must be mpeg4_gif
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Unique identifier for this result, 1-64 bytes
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * A valid URL for the MP4 file. File size must not exceed 1MB
    * @returns {string}
   */
   get mpeg4Url() {
       return this._mpeg4Url
   }

   /**
    * Video width
    * @returns {number|null}
   */
   get mpeg4Width() {
       return this._mpeg4Width
   }

   /**
    * Video height
    * @returns {number|null}
   */
   get mpeg4Height() {
       return this._mpeg4Height
   }

   /**
    * URL of the static thumbnail (jpeg or gif) for the result
    * @returns {string}
   */
   get thumbUrl() {
       return this._thumbUrl
   }

   /**
    * Title for the result
    * @returns {string|null}
   */
   get title() {
       return this._title
   }

   /**
    * Caption of the MPEG-4 file to be sent, 0-200 characters
    * @returns {string|null}
   */
   get caption() {
       return this._caption
   }

   /**
    * Inline keyboard attached to the message
    * @returns {InlineKeyboardMarkup|null}
   */
   get replyMarkup() {
       return this._replyMarkup
   }

   /**
    * Content of the message to be sent instead of the video animation
    * @returns {InputMessageContent|null}
   */
   get inputMessageContent() {
       return this._inputMessageContent
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQueryResultMpeg4Gif}
    */
   static deserialize(raw) {
      return new InlineQueryResultMpeg4Gif(
          raw[&#x27;type&#x27;],
          raw[&#x27;id&#x27;],
          raw[&#x27;mpeg4_url&#x27;],
          raw[&#x27;mpeg4_width&#x27;] ? raw[&#x27;mpeg4_width&#x27;] : null,
          raw[&#x27;mpeg4_height&#x27;] ? raw[&#x27;mpeg4_height&#x27;] : null,
          raw[&#x27;thumb_url&#x27;],
          raw[&#x27;title&#x27;] ? raw[&#x27;title&#x27;] : null,
          raw[&#x27;caption&#x27;] ? raw[&#x27;caption&#x27;] : null,
          raw[&#x27;reply_markup&#x27;] ? InlineKeyboardMarkup.deserialize(raw[&#x27;reply_markup&#x27;]) : null,
          raw[&#x27;input_message_content&#x27;] ? InputMessageContent.deserialize(raw[&#x27;input_message_content&#x27;]) : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undefined,
          id: this.id ? this.id : undefined,
          mpeg4_url: this.mpeg4Url ? this.mpeg4Url : undefined,
          mpeg4_width: this.mpeg4Width ? this.mpeg4Width : undefined,
          mpeg4_height: this.mpeg4Height ? this.mpeg4Height : undefined,
          thumb_url: this.thumbUrl ? this.thumbUrl : undefined,
          title: this.title ? this.title : undefined,
          caption: this.caption ? this.caption : undefined,
          reply_markup: this.replyMarkup ? this.replyMarkup.serialize() : undefined,
          input_message_content: this.inputMessageContent ? this.inputMessageContent.serialize() : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultPhoto" id="apidoc.element.telegram-node-bot.Models.InlineQueryResultPhoto">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultPhoto
        <span class="apidocSignatureSpan">( type, id, photoUrl, thumbUrl, photoWidth, photoHeight, title, description, caption, replyMarkup, inputMessageContent )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResultPhoto extends InlineQueryResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {string} id
    * @param {string} photoUrl
    * @param {string} thumbUrl
    * @param {number|null} [photoWidth]
    * @param {number|null} [photoHeight]
    * @param {string|null} [title]
    * @param {string|null} [description]
    * @param {string|null} [caption]
    * @param {InlineKeyboardMarkup|null} [replyMarkup]
    * @param {InputMessageContent|null} [inputMessageContent]
   */
</span>   constructor( type, id, photoUrl, thumbUrl, photoWidth, photoHeight, title, description, caption, replyMarkup, inputMessageContent ) {
       super()
       this._type = type
       this._id = id
       this._photoUrl = photoUrl
       this._thumbUrl = thumbUrl
       this._photoWidth = photoWidth
       this._photoHeight = photoHeight
       this._title = title
       this._description = description
       this._caption = caption
       this._replyMarkup = replyMarkup
       this._inputMessageContent = inputMessageContent
   }

   /**
    * Type of the result, must be photo
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Unique identifier for this result, 1-64 bytes
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * A valid URL of the photo. Photo must be in jpeg format. Photo size must not exceed 5MB
    * @returns {string}
   */
   get photoUrl() {
       return this._photoUrl
   }

   /**
    * URL of the thumbnail for the photo
    * @returns {string}
   */
   get thumbUrl() {
       return this._thumbUrl
   }

   /**
    * Width of the photo
    * @returns {number|null}
   */
   get photoWidth() {
       return this._photoWidth
   }

   /**
    * Height of the photo
    * @returns {number|null}
   */
   get photoHeight() {
       return this._photoHeight
   }

   /**
    * Title for the result
    * @returns {string|null}
   */
   get title() {
       return this._title
   }

   /**
    * Short description of the result
    * @returns {string|null}
   */
   get description() {
       return this._description
   }

   /**
    * Caption of the photo to be sent, 0-200 characters
    * @returns {string|null}
   */
   get caption() {
       return this._caption
   }

   /**
    * Inline keyboard attached to the message
    * @returns {InlineKeyboardMarkup|null}
   */
   get replyMarkup() {
       return this._replyMarkup
   }

   /**
    * Content of the message to be sent instead of the photo
    * @returns {InputMessageContent|null}
   */
   get inputMessageContent() {
       return this._inputMessageContent
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQueryResultPhoto}
    */
   static deserialize(raw) {
      return new InlineQueryResultPhoto(
          raw[&#x27;type&#x27;],
          raw[&#x27;id&#x27;],
          raw[&#x27;photo_url&#x27;],
          raw[&#x27;thumb_url&#x27;],
          raw[&#x27;photo_width&#x27;] ? raw[&#x27;photo_width&#x27;] : null,
          raw[&#x27;photo_height&#x27;] ? raw[&#x27;photo_height&#x27;] : null,
          raw[&#x27;title&#x27;] ? raw[&#x27;title&#x27;] : null,
          raw[&#x27;description&#x27;] ? raw[&#x27;description&#x27;] : null,
          raw[&#x27;caption&#x27;] ? raw[&#x27;caption&#x27;] : null,
          raw[&#x27;reply_markup&#x27;] ? InlineKeyboardMarkup.deserialize(raw[&#x27;reply_markup&#x27;]) : null,
          raw[&#x27;input_message_content&#x27;] ? InputMessageContent.deserialize(raw[&#x27;input_message_content&#x27;]) : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undefined,
          id: this.id ? this.id : undefined,
          photo_url: this.photoUrl ? this.photoUrl : undefined,
          thumb_url: this.thumbUrl ? this.thumbUrl : undefined,
          photo_width: this.photoWidth ? this.photoWidth : undefined,
          photo_height: this.photoHeight ? this.photoHeight : undefined,
          title: this.title ? this.title : undefined,
          description: this.description ? this.description : undefined,
          caption: this.caption ? this.caption : undefined, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultVenue" id="apidoc.element.telegram-node-bot.Models.InlineQueryResultVenue">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultVenue
        <span class="apidocSignatureSpan">( type, id, latitude, longitude, title, address, foursquareId, replyMarkup, inputMessageContent, thumbUrl, thumbWidth, thumbHeight )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResultVenue extends InlineQueryResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {string} id
    * @param {number} latitude
    * @param {number} longitude
    * @param {string} title
    * @param {string} address
    * @param {string|null} [foursquareId]
    * @param {InlineKeyboardMarkup|null} [replyMarkup]
    * @param {InputMessageContent|null} [inputMessageContent]
    * @param {string|null} [thumbUrl]
    * @param {number|null} [thumbWidth]
    * @param {number|null} [thumbHeight]
   */
</span>   constructor( type, id, latitude, longitude, title, address, foursquareId, replyMarkup, inputMessageContent, thumbUrl, thumbWidth, thumbHeight ) {
       super()
       this._type = type
       this._id = id
       this._latitude = latitude
       this._longitude = longitude
       this._title = title
       this._address = address
       this._foursquareId = foursquareId
       this._replyMarkup = replyMarkup
       this._inputMessageContent = inputMessageContent
       this._thumbUrl = thumbUrl
       this._thumbWidth = thumbWidth
       this._thumbHeight = thumbHeight
   }

   /**
    * Type of the result, must be venue
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Unique identifier for this result, 1-64 Bytes
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * Latitude of the venue location in degrees
    * @returns {number}
   */
   get latitude() {
       return this._latitude
   }

   /**
    * Longitude of the venue location in degrees
    * @returns {number}
   */
   get longitude() {
       return this._longitude
   }

   /**
    * Title of the venue
    * @returns {string}
   */
   get title() {
       return this._title
   }

   /**
    * Address of the venue
    * @returns {string}
   */
   get address() {
       return this._address
   }

   /**
    * Foursquare identifier of the venue if known
    * @returns {string|null}
   */
   get foursquareId() {
       return this._foursquareId
   }

   /**
    * Inline keyboard attached to the message
    * @returns {InlineKeyboardMarkup|null}
   */
   get replyMarkup() {
       return this._replyMarkup
   }

   /**
    * Content of the message to be sent instead of the venue
    * @returns {InputMessageContent|null}
   */
   get inputMessageContent() {
       return this._inputMessageContent
   }

   /**
    * Url of the thumbnail for the result
    * @returns {string|null}
   */
   get thumbUrl() {
       return this._thumbUrl
   }

   /**
    * Thumbnail width
    * @returns {number|null}
   */
   get thumbWidth() {
       return this._thumbWidth
   }

   /**
    * Thumbnail height
    * @returns {number|null}
   */
   get thumbHeight() {
       return this._thumbHeight
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQueryResultVenue}
    */
   static deserialize(raw) {
      return new InlineQueryResultVenue(
          raw[&#x27;type&#x27;],
          raw[&#x27;id&#x27;],
          raw[&#x27;latitude&#x27;],
          raw[&#x27;longitude&#x27;],
          raw[&#x27;title&#x27;],
          raw[&#x27;address&#x27;],
          raw[&#x27;foursquare_id&#x27;] ? raw[&#x27;foursquare_id&#x27;] : null,
          raw[&#x27;reply_markup&#x27;] ? InlineKeyboardMarkup.deserialize(raw[&#x27;reply_markup&#x27;]) : null,
          raw[&#x27;input_message_content&#x27;] ? InputMessageContent.deserialize(raw[&#x27;input_message_content&#x27;]) : null,
          raw[&#x27;thumb_url&#x27;] ? raw[&#x27;thumb_url&#x27;] : null,
          raw[&#x27;thumb_width&#x27;] ? raw[&#x27;thumb_width&#x27;] : null,
          raw[&#x27;thumb_height&#x27;] ? raw[&#x27;thumb_height&#x27;] : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undefined,
          id: this.id ? this.id : undefined,
          latitude: this.latitude ? this.latitude : undefined,
          longitude: this.longitude ? this.longitude : undefined,
          title: this.title ? this.title : undefined,
          address: this.address ? this.address : undefined,
          foursquare_id: this.foursquareId ? this.fou ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultVideo" id="apidoc.element.telegram-node-bot.Models.InlineQueryResultVideo">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultVideo
        <span class="apidocSignatureSpan">( type, id, videoUrl, mimeType, thumbUrl, title, caption, videoWidth, videoHeight, videoDuration, description, replyMarkup, inputMessageContent )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResultVideo extends InlineQueryResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {string} id
    * @param {string} videoUrl
    * @param {string} mimeType
    * @param {string} thumbUrl
    * @param {string} title
    * @param {string|null} [caption]
    * @param {number|null} [videoWidth]
    * @param {number|null} [videoHeight]
    * @param {number|null} [videoDuration]
    * @param {string|null} [description]
    * @param {InlineKeyboardMarkup|null} [replyMarkup]
    * @param {InputMessageContent|null} [inputMessageContent]
   */
</span>   constructor( type, id, videoUrl, mimeType, thumbUrl, title, caption, videoWidth, videoHeight, videoDuration, description, replyMarkup, inputMessageContent ) {
       super()
       this._type = type
       this._id = id
       this._videoUrl = videoUrl
       this._mimeType = mimeType
       this._thumbUrl = thumbUrl
       this._title = title
       this._caption = caption
       this._videoWidth = videoWidth
       this._videoHeight = videoHeight
       this._videoDuration = videoDuration
       this._description = description
       this._replyMarkup = replyMarkup
       this._inputMessageContent = inputMessageContent
   }

   /**
    * Type of the result, must be video
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Unique identifier for this result, 1-64 bytes
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * A valid URL for the embedded video player or video file
    * @returns {string}
   */
   get videoUrl() {
       return this._videoUrl
   }

   /**
    * Mime type of the content of video url, text/html or video/mp4
    * @returns {string}
   */
   get mimeType() {
       return this._mimeType
   }

   /**
    * URL of the thumbnail (jpeg only) for the video
    * @returns {string}
   */
   get thumbUrl() {
       return this._thumbUrl
   }

   /**
    * Title for the result
    * @returns {string}
   */
   get title() {
       return this._title
   }

   /**
    * Caption of the video to be sent, 0-200 characters
    * @returns {string|null}
   */
   get caption() {
       return this._caption
   }

   /**
    * Video width
    * @returns {number|null}
   */
   get videoWidth() {
       return this._videoWidth
   }

   /**
    * Video height
    * @returns {number|null}
   */
   get videoHeight() {
       return this._videoHeight
   }

   /**
    * Video duration in seconds
    * @returns {number|null}
   */
   get videoDuration() {
       return this._videoDuration
   }

   /**
    * Short description of the result
    * @returns {string|null}
   */
   get description() {
       return this._description
   }

   /**
    * Inline keyboard attached to the message
    * @returns {InlineKeyboardMarkup|null}
   */
   get replyMarkup() {
       return this._replyMarkup
   }

   /**
    * Content of the message to be sent instead of the video
    * @returns {InputMessageContent|null}
   */
   get inputMessageContent() {
       return this._inputMessageContent
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQueryResultVideo}
    */
   static deserialize(raw) {
      return new InlineQueryResultVideo(
          raw[&#x27;type&#x27;],
          raw[&#x27;id&#x27;],
          raw[&#x27;video_url&#x27;],
          raw[&#x27;mime_type&#x27;],
          raw[&#x27;thumb_url&#x27;],
          raw[&#x27;title&#x27;],
          raw[&#x27;caption&#x27;] ? raw[&#x27;caption&#x27;] : null,
          raw[&#x27;video_width&#x27;] ? raw[&#x27;video_width&#x27;] : null,
          raw[&#x27;video_height&#x27;] ? raw[&#x27;video_height&#x27;] : null,
          raw[&#x27;video_duration&#x27;] ? raw[&#x27;video_duration&#x27;] : null,
          raw[&#x27;description&#x27;] ? raw[&#x27;description&#x27;] : null,
          raw[&#x27;reply_markup&#x27;] ? InlineKeyboardMarkup.deserialize(raw[&#x27;reply_markup&#x27;]) : null,
          raw[&#x27;input_message_content&#x27;] ? InputMessageContent.deserialize(raw[&#x27;input_message_content&#x27;]) : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undef ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InlineQueryResultVoice" id="apidoc.element.telegram-node-bot.Models.InlineQueryResultVoice">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InlineQueryResultVoice
        <span class="apidocSignatureSpan">( type, id, voiceUrl, title, caption, voiceDuration, replyMarkup, inputMessageContent )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InlineQueryResultVoice extends InlineQueryResult {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {string} id
    * @param {string} voiceUrl
    * @param {string} title
    * @param {string|null} [caption]
    * @param {number|null} [voiceDuration]
    * @param {InlineKeyboardMarkup|null} [replyMarkup]
    * @param {InputMessageContent|null} [inputMessageContent]
   */
</span>   constructor( type, id, voiceUrl, title, caption, voiceDuration, replyMarkup, inputMessageContent ) {
       super()
       this._type = type
       this._id = id
       this._voiceUrl = voiceUrl
       this._title = title
       this._caption = caption
       this._voiceDuration = voiceDuration
       this._replyMarkup = replyMarkup
       this._inputMessageContent = inputMessageContent
   }

   /**
    * Type of the result, must be voice
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Unique identifier for this result, 1-64 bytes
    * @returns {string}
   */
   get id() {
       return this._id
   }

   /**
    * A valid URL for the voice recording
    * @returns {string}
   */
   get voiceUrl() {
       return this._voiceUrl
   }

   /**
    * Recording title
    * @returns {string}
   */
   get title() {
       return this._title
   }

   /**
    * Caption, 0-200 characters
    * @returns {string|null}
   */
   get caption() {
       return this._caption
   }

   /**
    * Recording duration in seconds
    * @returns {number|null}
   */
   get voiceDuration() {
       return this._voiceDuration
   }

   /**
    * Inline keyboard attached to the message
    * @returns {InlineKeyboardMarkup|null}
   */
   get replyMarkup() {
       return this._replyMarkup
   }

   /**
    * Content of the message to be sent instead of the voice recording
    * @returns {InputMessageContent|null}
   */
   get inputMessageContent() {
       return this._inputMessageContent
   }

   /**
    *
    * @param {Object} raw
    * @returns {InlineQueryResultVoice}
    */
   static deserialize(raw) {
      return new InlineQueryResultVoice(
          raw[&#x27;type&#x27;],
          raw[&#x27;id&#x27;],
          raw[&#x27;voice_url&#x27;],
          raw[&#x27;title&#x27;],
          raw[&#x27;caption&#x27;] ? raw[&#x27;caption&#x27;] : null,
          raw[&#x27;voice_duration&#x27;] ? raw[&#x27;voice_duration&#x27;] : null,
          raw[&#x27;reply_markup&#x27;] ? InlineKeyboardMarkup.deserialize(raw[&#x27;reply_markup&#x27;]) : null,
          raw[&#x27;input_message_content&#x27;] ? InputMessageContent.deserialize(raw[&#x27;input_message_content&#x27;]) : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undefined,
          id: this.id ? this.id : undefined,
          voice_url: this.voiceUrl ? this.voiceUrl : undefined,
          title: this.title ? this.title : undefined,
          caption: this.caption ? this.caption : undefined,
          voice_duration: this.voiceDuration ? this.voiceDuration : undefined,
          reply_markup: this.replyMarkup ? this.replyMarkup.serialize() : undefined,
          input_message_content: this.inputMessageContent ? this.inputMessageContent.serialize() : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InputContactMessageContent" id="apidoc.element.telegram-node-bot.Models.InputContactMessageContent">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InputContactMessageContent
        <span class="apidocSignatureSpan">(phoneNumber, firstName, lastName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InputContactMessageContent extends InputMessageContent {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} phoneNumber
    * @param {string} firstName
    * @param {string|null} [lastName]
   */
</span>   constructor(phoneNumber, firstName, lastName) {
       super()
       this._phoneNumber = phoneNumber
       this._firstName = firstName
       this._lastName = lastName
   }

   /**
    * Contact&#x27;s phone number
    * @returns {string}
   */
   get phoneNumber() {
       return this._phoneNumber
   }

   /**
    * Contact&#x27;s first name
    * @returns {string}
   */
   get firstName() {
       return this._firstName
   }

   /**
    * Contact&#x27;s last name
    * @returns {string|null}
   */
   get lastName() {
       return this._lastName
   }

   /**
    *
    * @param {Object} raw
    * @returns {InputContactMessageContent}
    */
   static deserialize(raw) {
      return new InputContactMessageContent(raw[&#x27;phone_number&#x27;], raw[&#x27;first_name&#x27;], raw[&#x27;last_name&#x27;] ? raw[&#x27;last_name&#x27;] : null)
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          phone_number: this.phoneNumber ? this.phoneNumber : undefined,
          first_name: this.firstName ? this.firstName : undefined,
          last_name: this.lastName ? this.lastName : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InputLocationMessageContent" id="apidoc.element.telegram-node-bot.Models.InputLocationMessageContent">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InputLocationMessageContent
        <span class="apidocSignatureSpan">(latitude, longitude)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InputLocationMessageContent extends InputMessageContent {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {number} latitude
    * @param {number} longitude
   */
</span>   constructor(latitude, longitude) {
       super()
       this._latitude = latitude
       this._longitude = longitude
   }

   /**
    * Latitude of the location in degrees
    * @returns {number}
   */
   get latitude() {
       return this._latitude
   }

   /**
    * Longitude of the location in degrees
    * @returns {number}
   */
   get longitude() {
       return this._longitude
   }

   /**
    *
    * @param {Object} raw
    * @returns {InputLocationMessageContent}
    */
   static deserialize(raw) {
      return new InputLocationMessageContent(raw[&#x27;latitude&#x27;], raw[&#x27;longitude&#x27;])
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          latitude: this.latitude ? this.latitude : undefined,
          longitude: this.longitude ? this.longitude : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InputMessageContent" id="apidoc.element.telegram-node-bot.Models.InputMessageContent">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InputMessageContent
        <span class="apidocSignatureSpan">(raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InputMessageContent {
<span class="apidocCodeCommentSpan">    /**
     *
     * @param {Object} raw
     * @returns {InputTextMessageContent|InputVenueMessageContent|InputContactMessageContent|InputLocationMessageContent}
     */
</span>    static deserialize(raw) {
        switch (raw) {
            case raw.message_text:
                return require(&#x27;./InputTextMessageContent&#x27;).deserialize(raw)
            case raw.latitude &#x26;&#x26; raw.title:
                return require(&#x27;./InputVenueMessageContent&#x27;).deserialize(raw)
            case raw.phone_number:
                return require(&#x27;./InputContactMessageContent&#x27;).deserialize(raw)
            case raw.latitude:
                return require(&#x27;./InputLocationMessageContent&#x27;).deserialize(raw)
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InputTextMessageContent" id="apidoc.element.telegram-node-bot.Models.InputTextMessageContent">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InputTextMessageContent
        <span class="apidocSignatureSpan">(messageText, parseMode, disableWebPagePreview)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InputTextMessageContent extends InputMessageContent {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} messageText
    * @param {string|null} [parseMode]
    * @param {boolean|null} [disableWebPagePreview]
   */
</span>   constructor(messageText, parseMode, disableWebPagePreview) {
       super()
       this._messageText = messageText
       this._parseMode = parseMode
       this._disableWebPagePreview = disableWebPagePreview
   }

   /**
    * Text of the message to be sent, 1-4096 characters
    * @returns {string}
   */
   get messageText() {
       return this._messageText
   }

   /**
    * Send Markdown or HTML, if you want Telegram apps to show bold, italic, fixed-width text or inline URLs in your bot&#x27;s message
.
    * @returns {string|null}
   */
   get parseMode() {
       return this._parseMode
   }

   /**
    * Disables link previews for links in the sent message
    * @returns {boolean|null}
   */
   get disableWebPagePreview() {
       return this._disableWebPagePreview
   }

   /**
    *
    * @param {Object} raw
    * @returns {InputTextMessageContent}
    */
   static deserialize(raw) {
      return new InputTextMessageContent(raw[&#x27;message_text&#x27;], raw[&#x27;parse_mode&#x27;] ? raw[&#x27;parse_mode&#x27;] : null, raw[&#x27;disable_web_page_preview
&#x27;] ? raw[&#x27;disable_web_page_preview&#x27;] : null)
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          message_text: this.messageText ? this.messageText : undefined,
          parse_mode: this.parseMode ? this.parseMode : undefined,
          disable_web_page_preview: this.disableWebPagePreview ? this.disableWebPagePreview : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.InputVenueMessageContent" id="apidoc.element.telegram-node-bot.Models.InputVenueMessageContent">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>InputVenueMessageContent
        <span class="apidocSignatureSpan">(latitude, longitude, title, address, foursquareId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class InputVenueMessageContent extends InputMessageContent {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {number} latitude
    * @param {number} longitude
    * @param {string} title
    * @param {string} address
    * @param {string|null} [foursquareId]
   */
</span>   constructor(latitude, longitude, title, address, foursquareId) {
       super()
       this._latitude = latitude
       this._longitude = longitude
       this._title = title
       this._address = address
       this._foursquareId = foursquareId
   }

   /**
    * Latitude of the venue in degrees
    * @returns {number}
   */
   get latitude() {
       return this._latitude
   }

   /**
    * Longitude of the venue in degrees
    * @returns {number}
   */
   get longitude() {
       return this._longitude
   }

   /**
    * Name of the venue
    * @returns {string}
   */
   get title() {
       return this._title
   }

   /**
    * Address of the venue
    * @returns {string}
   */
   get address() {
       return this._address
   }

   /**
    * Foursquare identifier of the venue, if known
    * @returns {string|null}
   */
   get foursquareId() {
       return this._foursquareId
   }

   /**
    *
    * @param {Object} raw
    * @returns {InputVenueMessageContent}
    */
   static deserialize(raw) {
      return new InputVenueMessageContent(
          raw[&#x27;latitude&#x27;],
          raw[&#x27;longitude&#x27;],
          raw[&#x27;title&#x27;],
          raw[&#x27;address&#x27;],
          raw[&#x27;foursquare_id&#x27;] ? raw[&#x27;foursquare_id&#x27;] : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          latitude: this.latitude ? this.latitude : undefined,
          longitude: this.longitude ? this.longitude : undefined,
          title: this.title ? this.title : undefined,
          address: this.address ? this.address : undefined,
          foursquare_id: this.foursquareId ? this.foursquareId : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.KeyboardButton" id="apidoc.element.telegram-node-bot.Models.KeyboardButton">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>KeyboardButton
        <span class="apidocSignatureSpan">(text, requestContact, requestLocation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class KeyboardButton {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} text
    * @param {boolean|null} [requestContact]
    * @param {boolean|null} [requestLocation]
   */
</span>   constructor(text, requestContact, requestLocation) {
       this._text = text
       this._requestContact = requestContact
       this._requestLocation = requestLocation
   }

   /**
    * Text of the button. If none of the optional fields are used, it will be sent to the bot as a message when the button is pressed
    * @returns {string}
   */
   get text() {
       return this._text
   }

   /**
    * If True, the user&#x27;s phone number will be sent as a contact when the button is pressed. Available in private chats only
    * @returns {boolean|null}
   */
   get requestContact() {
       return this._requestContact
   }

   /**
    * If True, the user&#x27;s current location will be sent when the button is pressed. Available in private chats only
    * @returns {boolean|null}
   */
   get requestLocation() {
       return this._requestLocation
   }

   /**
    *
    * @param {Object} raw
    * @returns {KeyboardButton}
    */
   static deserialize(raw) {
      return new KeyboardButton(raw[&#x27;text&#x27;], raw[&#x27;request_contact&#x27;] ? raw[&#x27;request_contact&#x27;] : null, raw[&#x27;request_location&#x27;] ? raw
[&#x27;request_location&#x27;] : null)
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          text: this.text ? this.text : undefined,
          request_contact: this.requestContact ? this.requestContact : undefined,
          request_location: this.requestLocation ? this.requestLocation : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.Location" id="apidoc.element.telegram-node-bot.Models.Location">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Location
        <span class="apidocSignatureSpan">(longitude, latitude)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Location {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {number} longitude
    * @param {number} latitude
   */
</span>   constructor(longitude, latitude) {
       this._longitude = longitude
       this._latitude = latitude
   }

   /**
    * Longitude as defined by sender
    * @returns {number}
   */
   get longitude() {
       return this._longitude
   }

   /**
    * Latitude as defined by sender
    * @returns {number}
   */
   get latitude() {
       return this._latitude
   }

   /**
    *
    * @param {Object} raw
    * @returns {Location}
    */
   static deserialize(raw) {
      return new Location(raw[&#x27;longitude&#x27;], raw[&#x27;latitude&#x27;])
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          longitude: this.longitude ? this.longitude : undefined,
          latitude: this.latitude ? this.latitude : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.Message" id="apidoc.element.telegram-node-bot.Models.Message">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Message
        <span class="apidocSignatureSpan">( messageId, from, date, chat, forwardFrom, forwardFromChat, forwardFromMessageId, forwardDate, replyToMessage, editDate, text, entities, audio, document, game, photo, sticker, video, voice, caption, contact, location, venue, newChatMember, leftChatMember, newChatTitle, newChatPhoto, deleteChatPhoto, groupChatCreated, supergroupChatCreated, channelChatCreated, migrateToChatId, migrateFromChatId, pinnedMessage )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Message {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {number} messageId
    * @param {User|null} [from]
    * @param {number} date
    * @param {Chat} chat
    * @param {User|null} [forwardFrom]
    * @param {Chat|null} [forwardFromChat]
    * @param {number|null} [forwardFromMessageId]
    * @param {number|null} [forwardDate]
    * @param {Message|null} [replyToMessage]
    * @param {number|null} [editDate]
    * @param {string|null} [text]
    * @param {MessageEntity[]|null} [entities]
    * @param {Audio|null} [audio]
    * @param {Document|null} [document]
    * @param {Game|null} [game]
    * @param {PhotoSize[]|null} [photo]
    * @param {Sticker|null} [sticker]
    * @param {Video|null} [video]
    * @param {Voice|null} [voice]
    * @param {string|null} [caption]
    * @param {Contact|null} [contact]
    * @param {Location|null} [location]
    * @param {Venue|null} [venue]
    * @param {User|null} [newChatMember]
    * @param {User|null} [leftChatMember]
    * @param {string|null} [newChatTitle]
    * @param {PhotoSize[]|null} [newChatPhoto]
    * @param {boolean|null} [deleteChatPhoto]
    * @param {boolean|null} [groupChatCreated]
    * @param {boolean|null} [supergroupChatCreated]
    * @param {boolean|null} [channelChatCreated]
    * @param {number|null} [migrateToChatId]
    * @param {number|null} [migrateFromChatId]
    * @param {Message|null} [pinnedMessage]
   */
</span>   constructor( messageId, from, date, chat, forwardFrom, forwardFromChat, forwardFromMessageId, forwardDate, replyToMessage, editDate, text, entities, audio, document, game, photo, sticker, video, voice, caption, contact, location, venue, newChatMember, leftChatMember, newChatTitle, newChatPhoto, deleteChatPhoto, groupChatCreated, supergroupChatCreated, channelChatCreated, migrateToChatId, migrateFromChatId, pinnedMessage ) {
       this._messageId = messageId
       this._from = from
       this._date = date
       this._chat = chat
       this._forwardFrom = forwardFrom
       this._forwardFromChat = forwardFromChat
       this._forwardFromMessageId = forwardFromMessageId
       this._forwardDate = forwardDate
       this._replyToMessage = replyToMessage
       this._editDate = editDate
       this._text = text
       this._entities = entities
       this._audio = audio
       this._document = document
       this._game = game
       this._photo = photo
       this._sticker = sticker
       this._video = video
       this._voice = voice
       this._caption = caption
       this._contact = contact
       this._location = location
       this._venue = venue
       this._newChatMember = newChatMember
       this._leftChatMember = leftChatMember
       this._newChatTitle = newChatTitle
       this._newChatPhoto = newChatPhoto
       this._deleteChatPhoto = deleteChatPhoto
       this._groupChatCreated = groupChatCreated
       this._supergroupChatCreated = supergroupChatCreated
       this._channelChatCreated = channelChatCreated
       this._migrateToChatId = migrateToChatId
       this._migrateFromChatId = migrateFromChatId
       this._pinnedMessage = pinnedMessage
   }

   /**
    * Unique message identifier inside this chat
    * @returns {number}
   */
   get messageId() {
       return this._messageId
   }

   /**
    * Sender, can be empty for messages sent to channels
    * @returns {User|null}
   */
   get from() {
       return this._from
   }

   /**
    * Date the message was sent in Unix time
    * @returns {number}
   */
   get date() {
       return this._date
   }

   /**
    * Conversation the message belongs to
    * @returns {Chat}
   */
   get chat() {
       return this._chat
   }

   /**
    * For forwarded messages, sender of the original message
    * @returns {User|null}
   */
   get forwardFrom() {
       return this._forwardFrom
   }

   /**
    * For messages forwarded from a channel, information about the original channel ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.MessageEntity" id="apidoc.element.telegram-node-bot.Models.MessageEntity">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>MessageEntity
        <span class="apidocSignatureSpan">(type, offset, length, url, user)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class MessageEntity {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} type
    * @param {number} offset
    * @param {number} length
    * @param {string|null} [url]
    * @param {User|null} [user]
   */
</span>   constructor(type, offset, length, url, user) {
       this._type = type
       this._offset = offset
       this._length = length
       this._url = url
       this._user = user
   }

   /**
    * Type of the entity. Can be mention (@username), hashtag, bot_command, url, email, bold (bold text), italic (italic text),
code (monowidth string), pre (monowidth block), text_link (for clickable text URLs), text_mention (for users without usernames)
    * @returns {string}
   */
   get type() {
       return this._type
   }

   /**
    * Offset in UTF-16 code units to the start of the entity
    * @returns {number}
   */
   get offset() {
       return this._offset
   }

   /**
    * Length of the entity in UTF-16 code units
    * @returns {number}
   */
   get length() {
       return this._length
   }

   /**
    * For text_link only, url that will be opened after user taps on the text
    * @returns {string|null}
   */
   get url() {
       return this._url
   }

   /**
    * For text_mention only, the mentioned user
    * @returns {User|null}
   */
   get user() {
       return this._user
   }

   /**
    *
    * @param {Object} raw
    * @returns {MessageEntity}
    */
   static deserialize(raw) {
      return new MessageEntity(
          raw[&#x27;type&#x27;],
          raw[&#x27;offset&#x27;],
          raw[&#x27;length&#x27;],
          raw[&#x27;url&#x27;] ? raw[&#x27;url&#x27;] : null,
          raw[&#x27;user&#x27;] ? User.deserialize(raw[&#x27;user&#x27;]) : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          type: this.type ? this.type : undefined,
          offset: this.offset ? this.offset : undefined,
          length: this.length ? this.length : undefined,
          url: this.url ? this.url : undefined,
          user: this.user ? this.user.serialize() : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.PhotoSize" id="apidoc.element.telegram-node-bot.Models.PhotoSize">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>PhotoSize
        <span class="apidocSignatureSpan">(fileId, width, height, fileSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PhotoSize {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} fileId
    * @param {number} width
    * @param {number} height
    * @param {number|null} [fileSize]
   */
</span>   constructor(fileId, width, height, fileSize) {
       this._fileId = fileId
       this._width = width
       this._height = height
       this._fileSize = fileSize
   }

   /**
    * Unique identifier for this file
    * @returns {string}
   */
   get fileId() {
       return this._fileId
   }

   /**
    * Photo width
    * @returns {number}
   */
   get width() {
       return this._width
   }

   /**
    * Photo height
    * @returns {number}
   */
   get height() {
       return this._height
   }

   /**
    * File size
    * @returns {number|null}
   */
   get fileSize() {
       return this._fileSize
   }

   /**
    *
    * @param {Object} raw
    * @returns {PhotoSize}
    */
   static deserialize(raw) {
      return new PhotoSize(raw[&#x27;file_id&#x27;], raw[&#x27;width&#x27;], raw[&#x27;height&#x27;], raw[&#x27;file_size&#x27;] ? raw[&#x27;file_size&#x27;] : null)
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          file_id: this.fileId ? this.fileId : undefined,
          width: this.width ? this.width : undefined,
          height: this.height ? this.height : undefined,
          file_size: this.fileSize ? this.fileSize : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.ReplyKeyboardMarkup" id="apidoc.element.telegram-node-bot.Models.ReplyKeyboardMarkup">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>ReplyKeyboardMarkup
        <span class="apidocSignatureSpan">(keyboard, resizeKeyboard, oneTimeKeyboard, selective)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ReplyKeyboardMarkup {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {KeyboardButton[][]} keyboard
    * @param {boolean|null} [resizeKeyboard]
    * @param {boolean|null} [oneTimeKeyboard]
    * @param {boolean|null} [selective]
   */
</span>   constructor(keyboard, resizeKeyboard, oneTimeKeyboard, selective) {
       this._keyboard = keyboard
       this._resizeKeyboard = resizeKeyboard
       this._oneTimeKeyboard = oneTimeKeyboard
       this._selective = selective
   }

   /**
    * Array of button rows, each represented by an Array of KeyboardButton objects
    * @returns {KeyboardButton[][]}
   */
   get keyboard() {
       return this._keyboard
   }

   /**
    * Requests clients to resize the keyboard vertically for optimal fit (e.g., make the keyboard smaller if there are just two
rows of buttons). Defaults to false, in which case the custom keyboard is always of the same height as the app&#x27;s standard keyboard
.
    * @returns {boolean|null}
   */
   get resizeKeyboard() {
       return this._resizeKeyboard
   }

   /**
    * Requests clients to hide the keyboard as soon as it&#x27;s been used. The keyboard will still be available, but clients will automatically
 display the usual letter-keyboard in the chat  the user can press a special button in the input field to see the custom keyboard
 again. Defaults to false.
    * @returns {boolean|null}
   */
   get oneTimeKeyboard() {
       return this._oneTimeKeyboard
   }

   /**
    * Use this parameter if you want to show the keyboard to specific users only. Targets: 1) users that are @mentioned in the text
 of the Message object; 2) if the bot&#x27;s message is a reply (has reply_to_message_id), sender of the original message.Example: A
user requests to change the bots language, bot replies to the request with a keyboard to select the new language. Other users in
 the group dont see the keyboard.
    * @returns {boolean|null}
   */
   get selective() {
       return this._selective
   }

   /**
    *
    * @param {Object} raw
    * @returns {ReplyKeyboardMarkup}
    */
   static deserialize(raw) {
      return new ReplyKeyboardMarkup(raw[&#x27;keyboard&#x27;] ? raw[&#x27;keyboard&#x27;].map(arr =&#x3e; arr.map(item =&#x3e; KeyboardButton.deserialize(item
))) : null, raw[&#x27;resize_keyboard&#x27;] ? raw[&#x27;resize_keyboard&#x27;] : null, raw[&#x27;one_time_keyboard&#x27;] ? raw[&#x27;one_time_keyboard&#x27;] : null,
raw[&#x27;selective&#x27;] ? raw[&#x27;selective&#x27;] : null)
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          keyboard: this.keyboard ? this.keyboard.map(arr =&#x3e; arr.map(item =&#x3e; item.serialize())) : undefined,
          resize_keyboard: this.resizeKeyboard ? this.resizeKeyboard : undefined,
          one_time_keyboard: this.oneTimeKeyboard ? this.oneTimeKeyboard : undefined,
          selective: this.selective ? this.selective : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.ReplyKeyboardRemove" id="apidoc.element.telegram-node-bot.Models.ReplyKeyboardRemove">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>ReplyKeyboardRemove
        <span class="apidocSignatureSpan">(removeKeyboard, selective)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ReplyKeyboardRemove {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {boolean} removeKeyboard
    * @param {boolean|null} [selective]
   */
</span>   constructor(removeKeyboard, selective) {
       this._removeKeyboard = removeKeyboard
       this._selective = selective
   }

   /**
    * Requests clients to remove the custom keyboard (user will not be able to summon this keyboard; if you want to hide the keyboard
 from sight but keep it accessible, use one_time_keyboard in ReplyKeyboardMarkup)
    * @returns {boolean}
   */
   get removeKeyboard() {
       return this._removeKeyboard
   }

   /**
    * Use this parameter if you want to remove the keyboard for specific users only. Targets: 1) users that are @mentioned in the
 text of the Message object; 2) if the bot&#x27;s message is a reply (has reply_to_message_id), sender of the original message.Example
: A user votes in a poll, bot returns confirmation message in reply to the vote and removes the keyboard for that user, while still
 showing the keyboard with poll options to users who haven&#x27;t voted yet.
    * @returns {boolean|null}
   */
   get selective() {
       return this._selective
   }

   /**
    *
    * @param {Object} raw
    * @returns {ReplyKeyboardRemove}
    */
   static deserialize(raw) {
      return new ReplyKeyboardRemove(raw[&#x27;remove_keyboard&#x27;], raw[&#x27;selective&#x27;] ? raw[&#x27;selective&#x27;] : null)
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          remove_keyboard: this.removeKeyboard ? this.removeKeyboard : undefined,
          selective: this.selective ? this.selective : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.ResponseParameters" id="apidoc.element.telegram-node-bot.Models.ResponseParameters">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>ResponseParameters
        <span class="apidocSignatureSpan">(migrateToChatId, retryAfter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ResponseParameters {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {number|null} [migrateToChatId]
    * @param {number|null} [retryAfter]
   */
</span>   constructor(migrateToChatId, retryAfter) {
       this._migrateToChatId = migrateToChatId
       this._retryAfter = retryAfter
   }

   /**
    * The group has been migrated to a supergroup with the specified identifier. This number may be greater than 32 bits and some
 programming languages may have difficulty/silent defects in interpreting it. But it is smaller than 52 bits, so a signed 64 bit
 integer or double-precision float type are safe for storing this identifier.
    * @returns {number|null}
   */
   get migrateToChatId() {
       return this._migrateToChatId
   }

   /**
    * In case of exceeding flood control, the number of seconds left to wait before the request can be repeated
    * @returns {number|null}
   */
   get retryAfter() {
       return this._retryAfter
   }

   /**
    *
    * @param {Object} raw
    * @returns {ResponseParameters}
    */
   static deserialize(raw) {
      return new ResponseParameters(raw[&#x27;migrate_to_chat_id&#x27;] ? raw[&#x27;migrate_to_chat_id&#x27;] : null, raw[&#x27;retry_after&#x27;] ? raw[&#x27;retry_after
&#x27;] : null)
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          migrate_to_chat_id: this.migrateToChatId ? this.migrateToChatId : undefined,
          retry_after: this.retryAfter ? this.retryAfter : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.Sticker" id="apidoc.element.telegram-node-bot.Models.Sticker">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Sticker
        <span class="apidocSignatureSpan">(fileId, width, height, thumb, emoji, fileSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Sticker {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} fileId
    * @param {number} width
    * @param {number} height
    * @param {PhotoSize|null} [thumb]
    * @param {string|null} [emoji]
    * @param {number|null} [fileSize]
   */
</span>   constructor(fileId, width, height, thumb, emoji, fileSize) {
       this._fileId = fileId
       this._width = width
       this._height = height
       this._thumb = thumb
       this._emoji = emoji
       this._fileSize = fileSize
   }

   /**
    * Unique identifier for this file
    * @returns {string}
   */
   get fileId() {
       return this._fileId
   }

   /**
    * Sticker width
    * @returns {number}
   */
   get width() {
       return this._width
   }

   /**
    * Sticker height
    * @returns {number}
   */
   get height() {
       return this._height
   }

   /**
    * Sticker thumbnail in .webp or .jpg format
    * @returns {PhotoSize|null}
   */
   get thumb() {
       return this._thumb
   }

   /**
    * Emoji associated with the sticker
    * @returns {string|null}
   */
   get emoji() {
       return this._emoji
   }

   /**
    * File size
    * @returns {number|null}
   */
   get fileSize() {
       return this._fileSize
   }

   /**
    *
    * @param {Object} raw
    * @returns {Sticker}
    */
   static deserialize(raw) {
      return new Sticker(
          raw[&#x27;file_id&#x27;],
          raw[&#x27;width&#x27;],
          raw[&#x27;height&#x27;],
          raw[&#x27;thumb&#x27;] ? PhotoSize.deserialize(raw[&#x27;thumb&#x27;]) : null,
          raw[&#x27;emoji&#x27;] ? raw[&#x27;emoji&#x27;] : null,
          raw[&#x27;file_size&#x27;] ? raw[&#x27;file_size&#x27;] : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          file_id: this.fileId ? this.fileId : undefined,
          width: this.width ? this.width : undefined,
          height: this.height ? this.height : undefined,
          thumb: this.thumb ? this.thumb.serialize() : undefined,
          emoji: this.emoji ? this.emoji : undefined,
          file_size: this.fileSize ? this.fileSize : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.Update" id="apidoc.element.telegram-node-bot.Models.Update">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Update
        <span class="apidocSignatureSpan">( updateId, message, editedMessage, channelPost, editedChannelPost, inlineQuery, chosenInlineResult, callbackQuery )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Update {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {number} updateId
    * @param {Message|null} [message]
    * @param {Message|null} [editedMessage]
    * @param {Message|null} [channelPost]
    * @param {Message|null} [editedChannelPost]
    * @param {InlineQuery|null} [inlineQuery]
    * @param {ChosenInlineResult|null} [chosenInlineResult]
    * @param {CallbackQuery|null} [callbackQuery]
   */
</span>   constructor( updateId, message, editedMessage, channelPost, editedChannelPost, inlineQuery, chosenInlineResult, callbackQuery ) {
       this._updateId = updateId
       this._message = message
       this._editedMessage = editedMessage
       this._channelPost = channelPost
       this._editedChannelPost = editedChannelPost
       this._inlineQuery = inlineQuery
       this._chosenInlineResult = chosenInlineResult
       this._callbackQuery = callbackQuery
   }

   /**
    * The updates unique identifier. Update identifiers start from a certain positive number and increase sequentially. This ID
 becomes especially handy if youre using Webhooks, since it allows you to ignore repeated updates or to restore the correct update
 sequence, should they get out of order.
    * @returns {number}
   */
   get updateId() {
       return this._updateId
   }

   /**
    * New incoming message of any kind  text, photo, sticker, etc.
    * @returns {Message|null}
   */
   get message() {
       return this._message
   }

   /**
    * New version of a message that is known to the bot and was edited
    * @returns {Message|null}
   */
   get editedMessage() {
       return this._editedMessage
   }

   /**
    * New incoming channel post of any kind  text, photo, sticker, etc.
    * @returns {Message|null}
   */
   get channelPost() {
       return this._channelPost
   }

   /**
    * New version of a channel post that is known to the bot and was edited
    * @returns {Message|null}
   */
   get editedChannelPost() {
       return this._editedChannelPost
   }

   /**
    * New incoming inline query
    * @returns {InlineQuery|null}
   */
   get inlineQuery() {
       return this._inlineQuery
   }

   /**
    * The result of an inline query that was chosen by a user and sent to their chat partner.
    * @returns {ChosenInlineResult|null}
   */
   get chosenInlineResult() {
       return this._chosenInlineResult
   }

   /**
    * New incoming callback query
    * @returns {CallbackQuery|null}
   */
   get callbackQuery() {
       return this._callbackQuery
   }

   /**
    *
    * @param {Object} raw
    * @returns {Update}
    */
   static deserialize(raw) {
      return new Update(
          raw[&#x27;update_id&#x27;],
          raw[&#x27;message&#x27;] ? Message.deserialize(raw[&#x27;message&#x27;]) : null,
          raw[&#x27;edited_message&#x27;] ? Message.deserialize(raw[&#x27;edited_message&#x27;]) : null,
          raw[&#x27;channel_post&#x27;] ? Message.deserialize(raw[&#x27;channel_post&#x27;]) : null,
          raw[&#x27;edited_channel_post&#x27;] ? Message.deserialize(raw[&#x27;edited_channel_post&#x27;]) : null,
          raw[&#x27;inline_query&#x27;] ? InlineQuery.deserialize(raw[&#x27;inline_query&#x27;]) : null,
          raw[&#x27;chosen_inline_result&#x27;] ? ChosenInlineResult.deserialize(raw[&#x27;chosen_inline_result&#x27;]) : null,
          raw[&#x27;callback_query&#x27;] ? CallbackQuery.deserialize(raw[&#x27;callback_query&#x27;]) : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          update_id: this.updateId ? this.updateId : undefined,
          message: this.message ? this.message.serialize() : undefined,
          edited_message: this.editedMessage ? this.editedMessage.serialize() : undefined,
          channel_post: this.channelPost ? this.channelPost.serialize() : undefined,
          edited_channel_post: this.editedChannelPost ? this.editedChannelPost.serialize() : undefined,
          inline_query: this.inlineQuery ? this.inlineQuery.serialize() : undefined,
          chosen_inline_result: this.chosenInlineResult ? this.chosenInlineResult.serialize() : undefined,
          callback_query: this.callbackQuery ? this.callbackQuery.serialize() : undef ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.User" id="apidoc.element.telegram-node-bot.Models.User">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>User
        <span class="apidocSignatureSpan">(id, firstName, lastName, username)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class User {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {number} id
    * @param {string} firstName
    * @param {string|null} [lastName]
    * @param {string|null} [username]
   */
</span>   constructor(id, firstName, lastName, username) {
       this._id = id
       this._firstName = firstName
       this._lastName = lastName
       this._username = username
   }

   /**
    * Unique identifier for this user or bot
    * @returns {number}
   */
   get id() {
       return this._id
   }

   /**
    * Users or bots first name
    * @returns {string}
   */
   get firstName() {
       return this._firstName
   }

   /**
    * Users or bots last name
    * @returns {string|null}
   */
   get lastName() {
       return this._lastName
   }

   /**
    * Users or bots username
    * @returns {string|null}
   */
   get username() {
       return this._username
   }

   /**
    *
    * @param {Object} raw
    * @returns {User}
    */
   static deserialize(raw) {
      return new User(raw[&#x27;id&#x27;], raw[&#x27;first_name&#x27;], raw[&#x27;last_name&#x27;] ? raw[&#x27;last_name&#x27;] : null, raw[&#x27;username&#x27;] ? raw[&#x27;username&#x27;] :
null)
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          id: this.id ? this.id : undefined,
          first_name: this.firstName ? this.firstName : undefined,
          last_name: this.lastName ? this.lastName : undefined,
          username: this.username ? this.username : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.UserProfilePhotos" id="apidoc.element.telegram-node-bot.Models.UserProfilePhotos">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>UserProfilePhotos
        <span class="apidocSignatureSpan">(totalCount, photos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class UserProfilePhotos {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {number} totalCount
    * @param {PhotoSize[][]} photos
   */
</span>   constructor(totalCount, photos) {
       this._totalCount = totalCount
       this._photos = photos
   }

   /**
    * Total number of profile pictures the target user has
    * @returns {number}
   */
   get totalCount() {
       return this._totalCount
   }

   /**
    * Requested profile pictures (in up to 4 sizes each)
    * @returns {PhotoSize[][]}
   */
   get photos() {
       return this._photos
   }

   /**
    *
    * @param {Object} raw
    * @returns {UserProfilePhotos}
    */
   static deserialize(raw) {
      return new UserProfilePhotos(raw[&#x27;total_count&#x27;], raw[&#x27;photos&#x27;] ? raw[&#x27;photos&#x27;].map(arr =&#x3e; arr.map(item =&#x3e; PhotoSize.deserialize
(item))) : null)
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          total_count: this.totalCount ? this.totalCount : undefined,
          photos: this.photos ? this.photos.map(arr =&#x3e; arr.map(item =&#x3e; item.serialize())) : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.Venue" id="apidoc.element.telegram-node-bot.Models.Venue">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Venue
        <span class="apidocSignatureSpan">(location, title, address, foursquareId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Venue {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {Location} location
    * @param {string} title
    * @param {string} address
    * @param {string|null} [foursquareId]
   */
</span>   constructor(location, title, address, foursquareId) {
       this._location = location
       this._title = title
       this._address = address
       this._foursquareId = foursquareId
   }

   /**
    * Venue location
    * @returns {Location}
   */
   get location() {
       return this._location
   }

   /**
    * Name of the venue
    * @returns {string}
   */
   get title() {
       return this._title
   }

   /**
    * Address of the venue
    * @returns {string}
   */
   get address() {
       return this._address
   }

   /**
    * Foursquare identifier of the venue
    * @returns {string|null}
   */
   get foursquareId() {
       return this._foursquareId
   }

   /**
    *
    * @param {Object} raw
    * @returns {Venue}
    */
   static deserialize(raw) {
      return new Venue(raw[&#x27;location&#x27;] ? Location.deserialize(raw[&#x27;location&#x27;]) : null, raw[&#x27;title&#x27;], raw[&#x27;address&#x27;], raw[&#x27;foursquare_id
&#x27;] ? raw[&#x27;foursquare_id&#x27;] : null)
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          location: this.location ? this.location.serialize() : undefined,
          title: this.title ? this.title : undefined,
          address: this.address ? this.address : undefined,
          foursquare_id: this.foursquareId ? this.foursquareId : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.Video" id="apidoc.element.telegram-node-bot.Models.Video">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Video
        <span class="apidocSignatureSpan">( fileId, width, height, duration, thumb, mimeType, fileSize )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Video {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} fileId
    * @param {number} width
    * @param {number} height
    * @param {number} duration
    * @param {PhotoSize|null} [thumb]
    * @param {string|null} [mimeType]
    * @param {number|null} [fileSize]
   */
</span>   constructor( fileId, width, height, duration, thumb, mimeType, fileSize ) {
       this._fileId = fileId
       this._width = width
       this._height = height
       this._duration = duration
       this._thumb = thumb
       this._mimeType = mimeType
       this._fileSize = fileSize
   }

   /**
    * Unique identifier for this file
    * @returns {string}
   */
   get fileId() {
       return this._fileId
   }

   /**
    * Video width as defined by sender
    * @returns {number}
   */
   get width() {
       return this._width
   }

   /**
    * Video height as defined by sender
    * @returns {number}
   */
   get height() {
       return this._height
   }

   /**
    * Duration of the video in seconds as defined by sender
    * @returns {number}
   */
   get duration() {
       return this._duration
   }

   /**
    * Video thumbnail
    * @returns {PhotoSize|null}
   */
   get thumb() {
       return this._thumb
   }

   /**
    * Mime type of a file as defined by sender
    * @returns {string|null}
   */
   get mimeType() {
       return this._mimeType
   }

   /**
    * File size
    * @returns {number|null}
   */
   get fileSize() {
       return this._fileSize
   }

   /**
    *
    * @param {Object} raw
    * @returns {Video}
    */
   static deserialize(raw) {
      return new Video(
          raw[&#x27;file_id&#x27;],
          raw[&#x27;width&#x27;],
          raw[&#x27;height&#x27;],
          raw[&#x27;duration&#x27;],
          raw[&#x27;thumb&#x27;] ? PhotoSize.deserialize(raw[&#x27;thumb&#x27;]) : null,
          raw[&#x27;mime_type&#x27;] ? raw[&#x27;mime_type&#x27;] : null,
          raw[&#x27;file_size&#x27;] ? raw[&#x27;file_size&#x27;] : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          file_id: this.fileId ? this.fileId : undefined,
          width: this.width ? this.width : undefined,
          height: this.height ? this.height : undefined,
          duration: this.duration ? this.duration : undefined,
          thumb: this.thumb ? this.thumb.serialize() : undefined,
          mime_type: this.mimeType ? this.mimeType : undefined,
          file_size: this.fileSize ? this.fileSize : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.Voice" id="apidoc.element.telegram-node-bot.Models.Voice">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>Voice
        <span class="apidocSignatureSpan">(fileId, duration, mimeType, fileSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Voice {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} fileId
    * @param {number} duration
    * @param {string|null} [mimeType]
    * @param {number|null} [fileSize]
   */
</span>   constructor(fileId, duration, mimeType, fileSize) {
       this._fileId = fileId
       this._duration = duration
       this._mimeType = mimeType
       this._fileSize = fileSize
   }

   /**
    * Unique identifier for this file
    * @returns {string}
   */
   get fileId() {
       return this._fileId
   }

   /**
    * Duration of the audio in seconds as defined by sender
    * @returns {number}
   */
   get duration() {
       return this._duration
   }

   /**
    * MIME type of the file as defined by sender
    * @returns {string|null}
   */
   get mimeType() {
       return this._mimeType
   }

   /**
    * File size
    * @returns {number|null}
   */
   get fileSize() {
       return this._fileSize
   }

   /**
    *
    * @param {Object} raw
    * @returns {Voice}
    */
   static deserialize(raw) {
      return new Voice(raw[&#x27;file_id&#x27;], raw[&#x27;duration&#x27;], raw[&#x27;mime_type&#x27;] ? raw[&#x27;mime_type&#x27;] : null, raw[&#x27;file_size&#x27;] ? raw[&#x27;file_size
&#x27;] : null)
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          file_id: this.fileId ? this.fileId : undefined,
          duration: this.duration ? this.duration : undefined,
          mime_type: this.mimeType ? this.mimeType : undefined,
          file_size: this.fileSize ? this.fileSize : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.telegram-node-bot.Models.WebhookInfo" id="apidoc.element.telegram-node-bot.Models.WebhookInfo">
        function <span class="apidocSignatureSpan">telegram-node-bot.Models.</span>WebhookInfo
        <span class="apidocSignatureSpan">( url, hasCustomCertificate, pendingUpdateCount, lastErrorDate, lastErrorMessage, maxConnections, allowedUpdates )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class WebhookInfo {
<span class="apidocCodeCommentSpan">   /**
    *
    * @param {string} url
    * @param {boolean} hasCustomCertificate
    * @param {number} pendingUpdateCount
    * @param {number|null} [lastErrorDate]
    * @param {string|null} [lastErrorMessage]
    * @param {number|null} [maxConnections]
    * @param {string[]|null} [allowedUpdates]
   */
</span>   constructor( url, hasCustomCertificate, pendingUpdateCount, lastErrorDate, lastErrorMessage, maxConnections, allowedUpdates ) {
       this._url = url
       this._hasCustomCertificate = hasCustomCertificate
       this._pendingUpdateCount = pendingUpdateCount
       this._lastErrorDate = lastErrorDate
       this._lastErrorMessage = lastErrorMessage
       this._maxConnections = maxConnections
       this._allowedUpdates = allowedUpdates
   }

   /**
    * Webhook URL, may be empty if webhook is not set up
    * @returns {string}
   */
   get url() {
       return this._url
   }

   /**
    * True, if a custom certificate was provided for webhook certificate checks
    * @returns {boolean}
   */
   get hasCustomCertificate() {
       return this._hasCustomCertificate
   }

   /**
    * Number of updates awaiting delivery
    * @returns {number}
   */
   get pendingUpdateCount() {
       return this._pendingUpdateCount
   }

   /**
    * Unix time for the most recent error that happened when trying to deliver an update via webhook
    * @returns {number|null}
   */
   get lastErrorDate() {
       return this._lastErrorDate
   }

   /**
    * Error message in human-readable format for the most recent error that happened when trying to deliver an update via webhook
    * @returns {string|null}
   */
   get lastErrorMessage() {
       return this._lastErrorMessage
   }

   /**
    * Maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery
    * @returns {number|null}
   */
   get maxConnections() {
       return this._maxConnections
   }

   /**
    * A list of update types the bot is subscribed to. Defaults to all update types
    * @returns {string[]|null}
   */
   get allowedUpdates() {
       return this._allowedUpdates
   }

   /**
    *
    * @param {Object} raw
    * @returns {WebhookInfo}
    */
   static deserialize(raw) {
      return new WebhookInfo(
          raw[&#x27;url&#x27;],
          raw[&#x27;has_custom_certificate&#x27;],
          raw[&#x27;pending_update_count&#x27;],
          raw[&#x27;last_error_date&#x27;] ? raw[&#x27;last_error_date&#x27;] : null,
          raw[&#x27;last_error_message&#x27;] ? raw[&#x27;last_error_message&#x27;] : null,
          raw[&#x27;max_connections&#x27;] ? raw[&#x27;max_connections&#x27;] : null,
          raw[&#x27;allowed_updates&#x27;] ? raw[&#x27;allowed_updates&#x27;] : null
      )
   }

   /**
    *
    * @returns {Object}
    */
   serialize() {
      return {
          url: this.url ? this.url : undefined,
          has_custom_certificate: this.hasCustomCertificate ? this.hasCustomCertificate : undefined,
          pending_update_count: this.pendingUpdateCount ? this.pendingUpdateCount : undefined,
          last_error_date: this.lastErrorDate ? this.lastErrorDate : undefined,
          last_error_message: this.lastErrorMessage ? this.lastErrorMessage : undefined,
          max_connections: this.maxConnections ? this.maxConnections : undefined,
          allowed_updates: this.allowedUpdates ? this.allowedUpdates : undefined
      }
   }

   /**
    *
    * @returns {string}
    */
   toJSON() {
      return this.serialize()
   }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
